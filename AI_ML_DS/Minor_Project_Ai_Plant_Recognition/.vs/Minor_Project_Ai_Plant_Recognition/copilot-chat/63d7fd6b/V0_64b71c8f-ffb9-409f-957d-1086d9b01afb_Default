Ü®DateTime◊ˇQ–•∞f(™ä™ThreadName¿∞CopilotSessionIdÇ§GuidŸ$64b71c8f-ffb9-409f-957d-1086d9b01afb®ClientIdÅ¢IdŸ4Microsoft.VisualStudio.Conversations.Chat.HelpWindowßRequestÅßRequestïŸ$6d37ed34-d3d2-4d55-8480-0490b83b6a63Ÿ$06b61383-8fbe-43b2-8c4a-0799437d3819ëÜØProviderMonikerÇ§NameŸ6Microsoft.VisualStudio.Copilot.DocumentContextProviderßVersion£0.1¶Member§file©CanReduce√©RequestIdŸ$6d37ed34-d3d2-4d55-8480-0490b83b6a63©Reference¿•Value»ÖÿdŸëMicrosoft.VisualStudio.Copilot.DocumentContext, Microsoft.VisualStudio.Copilot, Version=0.2.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3aÖßContent⁄Ñuusing Emgu.CV;
using Emgu.CV.CvEnum;
using Emgu.CV.Util;
using Python.Runtime;
using System.Drawing;

namespace Minor_Project_Ai_Plant_Recognition.SorceCode.Preprocessing
{
    /// <summary>
    /// This class is responsible for parsing images from the given directory path.
    /// It writes the paths of the images to a text file.
    /// </summary>
    internal class ImageAccess
    {
        /// <summary>
        /// Parses the directories for image files and writes their paths to a text file.
        /// </summary>
        /// <param name="path">The base path of the directories.</param>
        /// <param name="pathTextFile">The path of the text file to write to.</param>
        public void DirectoryParser(string path, string pathTextFile, string action)
        {
            string[] directories;
            List<string> directoriesList = pathMakerBasedOnAction(path, action);
            directories = directoriesList.ToArray();

            Directory.CreateDirectory(pathTextFile);

            if (action == "Augment" || action == "BckgrndRemove" || action == "Normalization")
            {
                DirParserByImgDim(directories, pathTextFile);
            }
            else if (action == "Resize" || action == "parse")
            {
                DirParserByClass(directories, pathTextFile);
            }
            else
            {
                throw new ArgumentOutOfRangeException($"The action '{action}' does not exist.");
            }
        }

        public void DirParserByClass(string[] directories, string pathTextFile)
        {
            foreach (string directory in directories)
            {
                if (!Directory.Exists(directory))
                {
                    throw new DirectoryNotFoundException($"The directory '{directory}' does not exist.");
                }

                using (StreamWriter writer = new(Path.Combine(pathTextFile, "dataset_base.txt"), false))
                {
                    foreach (string subdirectory in Directory.EnumerateDirectories(directory))
                    {
                        foreach (string filePath in Directory.EnumerateFiles(subdirectory))
                        {
                            string extension = Path.GetExtension(filePath);
                            if (extension == ".jpg" || extension == ".png")
                            {
                                writer.WriteLine(filePath);
                            }
                        }
                    }
                }
            }
        }

        public void DirParserByImgDim(string[] directories, string pathTextFile)
        {
            //using (StreamWriter writer = new(Path.Combine(pathTextFile, $"dataset_.{parentName}txt"), false))

            foreach (string directory in directories)
            {
                if (new DirectoryInfo(directory).Parent!.Name == "size224_224")
                {
                    if (!Directory.Exists(directory))
                    {
                        throw new DirectoryNotFoundException($"The directory '{directory}' does not exist.");
                    }
                    using (StreamWriter writer = new(Path.Combine(pathTextFile, $"dataset_size224_224.txt"), false))
                    {
                        foreach (string subdirectory in Directory.EnumerateDirectories(directory))
                        {
                            foreach (string filePath in Directory.EnumerateFiles(subdirectory))
                            {
                                string extension = Path.GetExtension(filePath);
                                if (extension == ".jpg" || extension == ".png")
                                {
                                    writer.WriteLine(filePath);
                                }
                            }
                        }
                    }
                }
                else if (new DirectoryInfo(directory).Parent!.Name == "size299_299")
                {
                    if (!Directory.Exists(directory))
                    {
                        throw new DirectoryNotFoundException($"The directory '{directory}' does not exist.");
                    }
                    using (StreamWriter writer = new(Path.Combine(pathTextFile, $"dataset_size299_299.txt"), false))
                    {
                        foreach (string subdirectory in Directory.EnumerateDirectories(directory))
                        {
                            foreach (string filePath in Directory.EnumerateFiles(subdirectory))
                            {
                                string extension = Path.GetExtension(filePath);
                                if (extension == ".jpg" || extension == ".png")
                                {
                                    writer.WriteLine(filePath);
                                }
                            }
                        }
                    }
                }
                else
                {
                    throw new DirectoryNotFoundException($"The directory does not exist.");
                }
            }
        }

        /// <summary>
        /// Constructs a list of directories based on the specified action.
        /// </summary>
        /// <param name="path">The base path to use when constructing the directories.</param>
        /// <param name="action">The action to base the directories on. Can be "resize", "parse", or "Augment".</param>
        /// <returns>A list of directories constructed based on the specified action.</returns>
        public List<string> pathMakerBasedOnAction(string path, string action)
        {
            List<string> directories = new List<string>();
            List<string> tempDir = new List<string>();

            if (action == "Resize" || action == "parse")
            {
                directories.Add(Path.Combine(path, "Medicinal_Leaf_dataset"));
                directories.Add(Path.Combine(path, "Medicinal_plant_dataset"));
            }
            else if (action == "Augment")
            {
                tempDir.Add(Path.Combine(path, "size224_224"));
                tempDir.Add(Path.Combine(path, "size299_299"));

                foreach (string dir in tempDir.ToList()) // Use ToList to create a copy for iteration
                {
                    directories.AddRange(pathMakerBasedOnAction(dir, "parse"));
                }
            }
            else if (action == "BckgrndRemove")
            {
                List<string> dirNames = new List<string> { "flipped", "noised", "resized", "rotated", "translated" };
                List<string> dimension = new List<string> { "size224_224", "size299_299" };
                foreach (string dirName in dirNames)
                {
                    foreach (string dim in dimension)
                    {
                        tempDir.Add(Path.Combine(path, dirName, dim));
                    }
                }

                foreach (string dir in tempDir.ToList()) // Use ToList to create a copy for iteration
                {
                    directories.AddRange(pathMakerBasedOnAction(dir, "parse"));
                }
            }
            else if (action == "Normalization")
            {
                List<string> dirNames = new List<string> { "flipped", "noised", "resized", "rotated", "translated" };
                List<string> dimension = new List<string> { "size224_224", "size299_299" };
                foreach (string dirName in dirNames)
                {
                    foreach (string dim in dimension)
                    {
                        tempDir.Add(Path.Combine(path, dirName, dim));
                    }
                }

                foreach (string dir in tempDir.ToList()) // Use ToList to create a copy for iteration
                {
                    directories.AddRange(pathMakerBasedOnAction(dir, "parse"));
                }
            }
            return directories;
        }
    }

    /// <summary>
    /// This class is responsible for writing images to a directory.
    /// </summary>
    internal class NewImageWrite
    {
        /// <summary>
        /// Creates a directory and writes an image to it.
        /// </summary>
        /// <param name="path">The path of the directory to create.</param>
        /// <param name="newImg">The image to write.</param>
        /// <param name="imgName">The name of the image file.</param>
        public static void DirrectoryCreate(string path, Mat newImg, string imgName)
        {
            if (!Directory.Exists(path))
            {
                try
                {
                    Directory.CreateDirectory(path);
                }
                catch (Exception e)
                {
                    Console.WriteLine($"Failed to create directory: {e}");
                }
            }

            WriteImage(path, newImg, imgName);
        }

        /// <summary>
        /// Writes an image to a file.
        /// </summary>
        /// <param name="path">The path of the file to write to.</param>
        /// <param name="newImg">The image to write.</param>
        /// <param name="imgName">The name of the image file.</param>
        private static void WriteImage(string path, Mat newImg, string imgName)
        {
            string newPath = Path.Combine(path, imgName);

            try
            {
                CvInvoke.Imwrite(newPath, newImg);
            }
            catch (IOException e)
            {
                Console.WriteLine("In NewImageWriter");
                Console.WriteLine($"Failed to write image: {e}");
            }
        }
    }

    /// <summary>
    /// This class is responsible for resizing images.
    /// </summary>
    internal class ImageResize
    {
        /// <summary>
        /// The directory to output the resized images to.
        /// </summary>
        public string OutputDirectory { get; } = "D:\\Project\\AI_ML_DS\\Minor_Project_Ai_Plant_Recognition\\Minor_Project_Ai_Plant_Recognition\\Data\\Dataset(resized)";

        private readonly NewImageWrite _newImageWrite = new NewImageWrite();

        /// <summary>
        /// Resizes the images specified in the text file at the given path.
        /// </summary>
        /// <param name="path">The path of the text file containing the image paths.</param>
        public void ResizeFactory(string path)
        {
            string path224 = Path.Combine(path, "dataset_size224_224.txt");
            string path299 = Path.Combine(path, "dataset_size299_299.txt");

            Task path224Task = Task.Run(() => ResizeDirectory(path224, "224Task"));
            Task path299Task = Task.Run(() => ResizeDirectory(path299, "299Task"));

            Task.WaitAll(path224Task, path299Task);
        }

        public void ResizeDirectory(string path, string taskName)
        {
            if (taskName == "224Task")
            {
                int totalLines = File.ReadLines(path).Count();
                {
                    using (StreamReader reader = new StreamReader(path))
                    {
                        string line;
                        while ((line = reader.ReadLine()!) != null)
                        {
                            Resizer(line, 224, 224);
                        }
                    }
                }
            }
            else if (taskName == "299Task")
            {
                int totalLines = File.ReadLines(path).Count();

                {
                    using (StreamReader reader = new StreamReader(path))
                    {
                        string line;
                        while ((line = reader.ReadLine()!) != null)
                        {
                            Resizer(line, 299, 299);
                        }
                    }
                }
            }
            else
            {
                throw new ArgumentOutOfRangeException($"The task '{taskName}' does not exist.");
            }
        }

        /// <summary>
        /// Resizes an image to the specified width and height.
        /// </summary>
        /// <param name="path">The path of the image to resize.</param>
        /// <param name="width">The width to resize to.</param>
        /// <param name="height">The height to resize to.</param>
        private void Resizer(string path, int width, int height)
        {
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);
            Mat resizedImage = new Mat();
            CvInvoke.Resize(image, resizedImage, new Size(width, height), 0, 0, Inter.Area);

            ImageWriterAssistance(path, resizedImage, width, height);
        }

        /// <summary>
        /// Assists in writing the resized image to the output directory.
        /// </summary>
        /// <param name="path">The path of the original image.</param>
        /// <param name="newImg">The resized image.</param>
        /// <param name="width">The width of the resized image.</param>
        /// <param name="height">The height of the resized image.</param>
        private void ImageWriterAssistance(string path, Mat newImg, int width, int height)
        {
            DirectoryInfo? dirParentInfo = new DirectoryInfo(path).Parent?.Parent;
            DirectoryInfo? dirInfo = new DirectoryInfo(path).Parent;
            string? dirName = dirInfo?.Name!;
            string? dirParentName = dirParentInfo?.Name!;
            string imgName = Path.GetFileName(path);
            string specificOutputDirectory = Path.Combine(OutputDirectory, $"size{width}_{height}", dirParentName, dirName);

            NewImageWrite.DirrectoryCreate(specificOutputDirectory, newImg, imgName);
        }
    }

    /// <summary>
    /// This class is responsible for Data Augmentation.
    /// </summary>
    internal class DataAugmentation
    {
        private readonly NewImageWrite _newImageWrite = new NewImageWrite();

        /// <summary>
        /// Augments the images specified in the text file at the given path.
        /// </summary>
        /// <param name="path">The path of the text file containing the image paths.</param>
        public void AugmentFactory(string path)
        {
            string path224 = Path.Combine(path, "dataset_size224_224.txt");
            string path299 = Path.Combine(path, "dataset_size299_299.txt");

            Task path224Task = Task.Run(() => AugmentDirectory(path224, "224Task"));
            Task path299Task = Task.Run(() => AugmentDirectory(path299, "299Task"));

            Task.WaitAll(path224Task, path299Task);
        }

        public void AugmentDirectory(string path, string taskName)
        {
            if (taskName == "224Task")
            {
                int totalLines = File.ReadLines(path).Count();
                {
                    using (StreamReader reader = new StreamReader(path))
                    {
                        string line;
                        while ((line = reader.ReadLine()!) != null)
                        {
                            FlipAugmenter(line);
                            RotateAugmenter(line);
                            NoiseAugmenter(line);
                            TranslateAugmenter(line);
                            CopyResizedImage(line);
                        }
                    }
                }
            }
            else if (taskName == "299Task")
            {
                int totalLines = File.ReadLines(path).Count();
                {
                    using (StreamReader reader = new StreamReader(path))
                    {
                        string line;
                        while ((line = reader.ReadLine()!) != null)
                        {
                            FlipAugmenter(line);
                            RotateAugmenter(line);
                            NoiseAugmenter(line);
                            TranslateAugmenter(line);
                            CopyResizedImage(line);
                        }
                    }
                }
            }
            else
            {
                throw new ArgumentOutOfRangeException($"The task '{taskName}' does not exist.");
            }
        }

        /// <summary>
        /// Augments an image by flipping it.
        /// </summary>
        /// <param name="path">The path of the image to augment.</param>
        private void FlipAugmenter(string path)
        {
            string action = "flipped";
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);
            Mat flippedImage = new Mat();
            CvInvoke.Flip(image, flippedImage, FlipType.Both);

            ImageWriterAssistance(path, flippedImage, action);
        }

        /// <summary>
        /// Augments an image by rotating it.
        /// </summary>
        /// <param name="path">The path of the image to augment.</param>
        private void RotateAugmenter(string path)
        {
            string action = "rotated";
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);
            Mat rotatedImage = new Mat();
            CvInvoke.Rotate(image, rotatedImage, RotateFlags.Rotate90Clockwise);

            ImageWriterAssistance(path, rotatedImage, action);
        }

        /// <summary>
        /// Augments an image by adding noise to it.
        /// </summary>
        /// <param name="path">The path of the image to augment.</param>
        private void NoiseAugmenter(string path)
        {
            string action = "noised";
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);
            Mat noisedImage = new Mat();
            CvInvoke.GaussianBlur(image, noisedImage, new Size(5, 5), 0);

            ImageWriterAssistance(path, noisedImage, action);
        }

        /// <summary>
        /// Augments an image by translating it.
        /// </summary>
        /// <param name="path">The path of the image to augment.</param>
        private void TranslateAugmenter(string path)
        {
            string action = "translated";
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);
            int imageWidth = image.Width;
            int imageHeight = image.Height;
            Mat translatedImage = new Mat();
            Matrix<float> shiftMatrix = new Matrix<float>(2, 3);
            Random rand = new Random();
            int shiftX = rand.Next(-50, 50);  // Random shift in x direction between -50 and 50
            int shiftY = rand.Next(-50, 50);  // Random shift in y direction between -50 and 50

            shiftMatrix[0, 0] = 1;  // Identity element
            shiftMatrix[1, 1] = 1;  // Identity element
            shiftMatrix[0, 2] = shiftX;  // Shift in x direction
            shiftMatrix[1, 2] = shiftY;  // Shift in y direction
            CvInvoke.WarpAffine(image, translatedImage, shiftMatrix, new Size(imageWidth, imageHeight), 0);

            ImageWriterAssistance(path, translatedImage, action);
        }

        /// <summary>
        /// Augments an image by copying it to the output directory.
        /// </summary>
        /// <param name="path"></param>
        private void CopyResizedImage(string path)
        {
            string action = "resized";
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);
            Mat copyResizedImage = image;

            ImageWriterAssistance(path, copyResizedImage, action);
        }

        /// <summary>
        /// The directory to output the augmented images to.
        /// </summary>
        public string OutputDirectory { get; } = "D:\\Project\\AI_ML_DS\\Minor_Project_Ai_Plant_Recognition\\Minor_Project_Ai_Plant_Recognition\\Data\\Dataset(augmented)";

        /// <summary>
        /// Assists in writing the augmented image to the output directory.
        /// </summary>
        /// <param name="path">The path of the original image.</param>
        /// <param name="newImg">The augmented image.</param>
        private void ImageWriterAssistance(string path, Mat newImg, string action)
        {
            DirectoryInfo? directoryParentParentInfo = new DirectoryInfo(path).Parent?.Parent?.Parent;
            DirectoryInfo? dirParentInfo = new DirectoryInfo(path).Parent?.Parent;
            DirectoryInfo? dirInfo = new DirectoryInfo(path).Parent;
            string? dirName = dirInfo?.Name!;
            string? dirParentName = dirParentInfo?.Name!;
            string? dirParentParentName = directoryParentParentInfo?.Name!;
            string imgName = Path.GetFileName(path);
            string specificOutputDirectory = Path.Combine(OutputDirectory, action, dirParentParentName, dirParentName, dirName);

            NewImageWrite.DirrectoryCreate(specificOutputDirectory, newImg, imgName);
        }
    }

    /// <summary>
    /// This class is responsible for removing the background from images.
    /// </summary>
    internal class BckgrndRemover
    {
        private readonly NewImageWrite _newImageWrite = new NewImageWrite();

        /// <summary>
        /// Removes the background from the images specified in the text file at the given path.
        /// </summary>
        /// <param name="path">The path of the text file containing the image paths.</param>
        public void RemoveBackgroundFactory(string path)
        {
            string path224 = Path.Combine(path, "dataset_size224_224.txt");
            string path299 = Path.Combine(path, "dataset_size299_299.txt");

            Task path224Task = Task.Run(() => BackGrndRemoveDirectory(path224, "224Task"));
            Task path299Task = Task.Run(() => BackGrndRemoveDirectory(path299, "299Task"));

            Task.WaitAll(path224Task, path299Task);
            //// Path to the Python DLL
            //Runtime.PythonDLL = @"C:\Users\kumar\AppData\Local\Programs\Python\Python312\python312.dll";
            //// Setting the PYTHONHOME environment variable
            //Environment.SetEnvironmentVariable("PYTHONHOME", @"C:\Users\kumar\AppData\Local\Programs\Python\Python312", EnvironmentVariableTarget.Process);

            //try
            //{
            //    // Initialize the Python Engine
            //    PythonEngine.Initialize();

            //    int totalLines = File.ReadLines(Path.Combine(path, "dataset.txt")).Count();
            //    using (var pbar = new ProgressBar(totalLines, "Removing Background", new ProgressBarOptions { ProgressCharacter = '#' }))
            //    {
            //        using (StreamReader reader = new StreamReader(Path.Combine(path, "dataset.txt")))
            //        {
            //            string line;
            //            while ((line = reader.ReadLine()!) != null)
            //            {
            //                PythonScriptRemoveBackground(line);
            //                pbar.Tick();
            //            }
            //        }
            //    }
            //}
            //catch (Exception e)
            //{
            //    Console.WriteLine($"Failed to remove background: {e.Message}");
            //}
            //finally
            //{
            //    // Shutdown the Python Engine
            //    PythonEngine.Shutdown();
            //}
        }

        private void BackGrndRemoveDirectory(string path, string taskName)
        {
            // Path to the Python DLL
            Runtime.PythonDLL = @"C:\Users\kumar\AppData\Local\Programs\Python\Python312\python312.dll";
            // Setting the PYTHONHOME environment variable
            Environment.SetEnvironmentVariable("PYTHONHOME", @"C:\Users\kumar\AppData\Local\Programs\Python\Python312", EnvironmentVariableTarget.Process);

            try
            {
                PythonEngine.Initialize();

                if (taskName == "224Task")
                {
                    int totalLines = File.ReadLines(path).Count();
                    {
                        using (StreamReader reader = new StreamReader(path))
                        {
                            string line;
                            while ((line = reader.ReadLine()!) != null)
                            {
                                PythonScriptRemoveBackground(line);
                            }
                        }
                    }
                }
                else if (taskName == "299Task")
                {
                    int totalLines = File.ReadLines(path).Count();
                    {
                        using (StreamReader reader = new StreamReader(path))
                        {
                            string line;
                            while ((line = reader.ReadLine()!) != null)
                            {
                                PythonScriptRemoveBackground(line);
                            }
                        }
                    }
                }
                else
                {
                    throw new ArgumentOutOfRangeException($"The task '{taskName}' does not exist.");
                }
            }
            catch (Exception e)
            {
                Console.WriteLine($"Failed to remove background: {e.Message}");
            }
            finally
            {
                // Shutdown the Python Engine
                PythonEngine.Shutdown();
            }
        }

        /// <summary>
        /// Executes a Python script to remove the background from an image.
        /// </summary>
        /// <param name="path">The path of the image to process.</param>
        private void PythonScriptRemoveBackground(string path)
        {
            using (Py.GIL())
            {
                // Get the output path for the processed image
                string outputPath = ImageWriterAssistance(path);

                // Read the Python script
                string pythonScript = System.IO.File.ReadAllText(@"D:\Project\AI_ML_DS\Minor_Project_Ai_Plant_Recognition\Minor_Project_Ai_Plant_Recognition\SorceCode\remove_background.py");
                // Run the Python script
                PythonEngine.RunSimpleString(pythonScript);
                // Call the remove_backgrnd function from the Python script
                dynamic removeBackground = PythonEngine.RunSimpleString($"remove_backgrnd(r'{path}', r'{outputPath}')");
            }
        }

        /// <summary>
        /// The directory to output the images with the background removed to.
        /// </summary>
        public string OutputDirectory { get; } = "D:\\Project\\AI_ML_DS\\Minor_Project_Ai_Plant_Recognition\\Minor_Project_Ai_Plant_Recognition\\Data\\Dataset(background_removed)";

        /// <summary>
        /// Assists in writing the image with the background removed to the output directory.
        /// </summary>
        /// <param name="path">The path of the original image.</param>
        /// <param name="newImg">The image with the background removed.</param>
        private string ImageWriterAssistance(string path)
        {
            DirectoryInfo? dirParentParentParentInfo = new DirectoryInfo(path).Parent?.Parent?.Parent?.Parent;
            DirectoryInfo? dirParentParentInfo = new DirectoryInfo(path).Parent?.Parent?.Parent;
            DirectoryInfo? dirParentInfo = new DirectoryInfo(path).Parent?.Parent;
            DirectoryInfo? dirInfo = new DirectoryInfo(path).Parent;
            string? dirName = dirInfo?.Name!;
            string? dirParentName = dirParentInfo?.Name!;
            string? dirParentParentName = dirParentParentInfo?.Name!;
            string? dirParentParentParentName = dirParentParentParentInfo?.Name!;
            string imgName = Path.GetFileName(path);
            string specificOutputDirectory = Path.Combine(OutputDirectory, dirParentParentParentName, dirParentParentName, dirParentName, dirName);

            return Path.Combine(specificOutputDirectory, imgName);
            // Regular image write is not needed.
            //_newImageWrite.DirrectoryCreate(specificOutputDirectory, newImg, imgName);
        }
    }

    /// <summary>
    /// This class is responsble for normalization of images data.
    /// </summary>
    internal class Normalization
    {
        private readonly NewImageWrite _newImageWrite = new NewImageWrite();

        /// <summary>
        /// Normalizes the images specified in the text file at the given path.
        /// </summary>
        /// <param name="path">The path of the text file containing the image paths.</param>
        public void NormalizationFactor(string path)
        {
            string path224 = Path.Combine(path, "dataset_size224_224.txt");
            string path299 = Path.Combine(path, "dataset_size299_299.txt");

            Task path224Task = Task.Run(() => NormalizeDirectory(path224, "224Task"));
            Task path299Task = Task.Run(() => NormalizeDirectory(path299, "299Task"));

            Task.WaitAll(path224Task, path299Task);
            //int totalLines = File.ReadLines(Path.Combine(path, "dataset.txt")).Count();

            //using (var pbar = new ProgressBar(totalLines, "Resizing", new ProgressBarOptions { ProgressCharacter = '#' }))
            //{
            //    using (StreamReader reader = new StreamReader(Path.Combine(path, "dataset.txt")))
            //    {
            //        string line;
            //        while ((line = reader.ReadLine()!) != null)
            //        {
            //            NormalizeColorWise(line);
            //            pbar.Tick();
            //        }
            //    }
            //}
        }

        private void NormalizeDirectory(string path, string taskName)
        {
            if (taskName == "224Task")
            {
                int totalLines = File.ReadLines(path).Count();
                {
                    using (StreamReader reader = new StreamReader(path))
                    {
                        string line;
                        while ((line = reader.ReadLine()!) != null)
                        {
                            NormalizeColorWise(line);
                        }
                    }
                }
            }
            else if (taskName == "299Task")
            {
                int totalLines = File.ReadLines(path).Count();
                {
                    using (StreamReader reader = new StreamReader(path))
                    {
                        string line;
                        while ((line = reader.ReadLine()!) != null)
                        {
                            NormalizeColorWise(line);
                        }
                    }
                }
            }
            else
            {
                throw new ArgumentOutOfRangeException($"The task '{taskName}' does not exist.");
            }
        }

        /// <summary>
        /// Normalizes an image using min-max.
        /// </summary>
        /// <param name="path">The path of the image to process.</param>
        public void NormalizeColorWise(string path)
        {
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);

            Mat normalizedImage = image.Clone();
            VectorOfMat vm = new VectorOfMat();
            CvInvoke.Split(image, vm);

            for (int i = 0; i < vm.Size; i++)
            {
                Mat channel = vm[i];
                CvInvoke.Normalize(channel, channel, 0, 255, NormType.MinMax);
            }
            CvInvoke.Merge(vm, normalizedImage);

            ImageWriterAssistance(path, normalizedImage);
        }

        /// <summary>
        /// The directory to output the normalized images to the directory.
        /// </summary>
        public string OutputDirectory { get; } = "D:\\Project\\AI_ML_DS\\Minor_Project_Ai_Plant_Recognition\\Minor_Project_Ai_Plant_Recognition\\Data\\Dataset(normalized)";

        /// <summary>
        /// Assists in writing the normalized image to the output directory.
        /// </summary>
        /// <param name="path">The path of the original image.</param>
        /// <param name="newImg">The image with the background removed.</param>

        private void ImageWriterAssistance(string path, Mat newImg)
        {
            DirectoryInfo? dirParentParentParentInfo = new DirectoryInfo(path).Parent?.Parent?.Parent?.Parent;
            DirectoryInfo? dirParentParentInfo = new DirectoryInfo(path).Parent?.Parent?.Parent;
            DirectoryInfo? dirParentInfo = new DirectoryInfo(path).Parent?.Parent;
            DirectoryInfo? dirInfo = new DirectoryInfo(path).Parent;
            string? dirName = dirInfo?.Name!;
            string? dirParentName = dirParentInfo?.Name!;
            string? dirParentParentName = dirParentParentInfo?.Name!;
            string? dirParentParentParentName = dirParentParentParentInfo?.Name!;
            string imgName = Path.GetFileName(path);
            string specificOutputDirectory = Path.Combine(OutputDirectory, dirParentParentParentName, dirParentParentName, dirParentName, dirName);

            NewImageWrite.DirrectoryCreate(specificOutputDirectory, newImg, imgName);
        }
    }
}ØOriginalContent¿™SelectionsëÉ•Caret¿•StartÕ)Æ£EndÕ0N®FilePathŸxD:\Project\AI_ML_DS\Minor_Project_Ai_Plant_Recognition\Minor_Project_Ai_Plant_Recognition\SorceCode\DataPreprocessing.cs®Language¢C#ëíìÅ•Value ŸØhey, in image resize we dont have seperate size file. image resize actually make directory based on image dim. i want to remove this task system and apply simple parallel task¿®ResponseÖßContent⁄ÖSure, you can use the `Parallel.ForEach` method to process the lines in the file concurrently. This method is part of the `System.Threading.Tasks` namespace and it provides a simple way to parallelize your code.

Here's how you can modify your `ResizeDirectory` method to use `Parallel.ForEach`:

```csharp
public void ResizeDirectory(string path, int width, int height)
{
    var lines = File.ReadLines(path);
    Parallel.ForEach(lines, line =>
    {
        Resizer(line, width, height);
    });
}
```

And then you can call this method for different sizes like this:

```csharp
public void ResizeFactory(string path)
{
    string path224 = Path.Combine(path, "dataset_size224_224.txt");
    string path299 = Path.Combine(path, "dataset_size299_299.txt");

    ResizeDirectory(path224, 224, 224);
    ResizeDirectory(path299, 299, 299);
}
```

This code will read each line from the file and resize the image on that line in parallel. The `Parallel.ForEach` method will automatically manage the degree of parallelism based on the number of available processors.

Please note that the degree of parallelism and the actual performance gain will depend on the number of cores in your CPU and the nature of the `Resizer` method. If the `Resizer` method is I/O bound (for example, if it reads/writes files), then you might not see a significant performance improvement because I/O operations are not parallelizable.§Type ¶StatusØFollowUpPromptsíŸ2How can I handle exceptions in the parallel tasks?ŸGCan I limit the degree of parallelism in the `Parallel.ForEach` method?≥CodeVulnerabilitiesê∂LoggedSkillInvocations¿Ü®DateTime◊ˇÏËl‡f(∞™ThreadName¿∞CopilotSessionIdÇ§GuidŸ$64b71c8f-ffb9-409f-957d-1086d9b01afb®ClientIdÅ¢IdŸ4Microsoft.VisualStudio.Conversations.Chat.HelpWindowßRequestÅßRequestïŸ$c469834d-66ab-47b0-ae70-50bf16396b7fŸ$ab965d6c-86de-4083-b4b0-b316c31473adêëíìÅ•Value Ÿ6i want to delete directory if exist. how can i do that¿®ResponseÖßContent⁄0You can use the `Directory.Delete` method from the `System.IO` namespace to delete a directory. Here's how you can do it:

```csharp
if (Directory.Exists(path))
{
    Directory.Delete(path, true);
}
```

In this code, `path` is the path of the directory you want to delete. The second parameter to the `Delete` method is a boolean that determines whether to delete subdirectories and files. If it's `true`, the directory, its subdirectories, and all files are deleted. If it's `false` and the directory contains files or subdirectories, an exception is thrown.§Type ¶StatusØFollowUpPromptsíŸ<How can I check if a file exists before trying to delete it?Ÿ<Can I catch exceptions if the deletion of a directory fails?≥CodeVulnerabilitiesê∂LoggedSkillInvocations¿Ü®DateTime◊ˇ·ÇDpf(∞S™ThreadName¿∞CopilotSessionIdÇ§GuidŸ$64b71c8f-ffb9-409f-957d-1086d9b01afb®ClientIdÅ¢IdŸ4Microsoft.VisualStudio.Conversations.Chat.HelpWindowßRequestÅßRequestïŸ$9afd72fe-4a7e-4a93-8c01-51d2da5f8f4aŸ$b25bc561-d322-44ea-9fd4-8192a9b343a1êëíìÅ•Value ºsorry not directory but file¿®ResponseÖßContent⁄¥To delete a file, you can use the `File.Delete` method from the `System.IO` namespace. Here's how you can do it:

```csharp
if (File.Exists(path))
{
    File.Delete(path);
}
```

In this code, `path` is the path of the file you want to delete. The `File.Exists` method checks if the file exists, and the `File.Delete` method deletes it if it does. If the file does not exist, `File.Delete` does nothing (it does not throw an exception).§Type ¶StatusØFollowUpPromptsíŸCHow can I check if a file is in use before attempting to delete it?ŸCCan I recover a file after it has been deleted using `File.Delete`?≥CodeVulnerabilitiesê∂LoggedSkillInvocations¿Ü®DateTime◊ˇ›cf(¥§™ThreadName¿∞CopilotSessionIdÇ§GuidŸ$64b71c8f-ffb9-409f-957d-1086d9b01afb®ClientIdÅ¢IdŸ4Microsoft.VisualStudio.Conversations.Chat.HelpWindowßRequestÅßRequestïŸ$de488b6f-0979-4592-a040-5c11211545ffŸ$aa37928f-094f-4a54-8cb8-2729fab0edb8êëíìÅ•Value Ÿ(can i initialize python engine in thread¿®ResponseÖßContent⁄Yes, you can initialize the Python engine in a separate thread. However, you need to be aware of some important points:

1. Python's Global Interpreter Lock (GIL) ensures that only one thread executes Python bytecode at a time, even in multi-threaded programs. This means that multi-threading in Python might not give you the performance boost you expect, especially for CPU-bound tasks.

2. The Python engine should be initialized only once. If you try to initialize it multiple times, it may cause issues.

3. You need to ensure that the Python engine is initialized before you use any Python-related functionality in your threads.

Here's an example of how you can initialize the Python engine in a separate thread:

```csharp
using Python.Runtime;

public void InitializePythonEngine()
{
    new Thread(() =>
    {
        if (!PythonEngine.IsInitialized)
        {
            PythonEngine.Initialize();
        }
    }).Start();
}
```

In this code, a new thread is created and started. Inside the thread, we check if the Python engine is already initialized using the `PythonEngine.IsInitialized` property. If it's not, we initialize it using the `PythonEngine.Initialize` method.

Remember to call `InitializePythonEngine` before using any Python-related functionality in your threads.§Type ¶StatusØFollowUpPromptsíŸXHow can I ensure that the Python engine is properly shut down when my application exits?ŸNCan I use Python libraries in my C# code after initializing the Python engine?≥CodeVulnerabilitiesê∂LoggedSkillInvocations¿Ü®DateTime◊ˇ∆Ω^@f(¥¿™ThreadName¿∞CopilotSessionIdÇ§GuidŸ$64b71c8f-ffb9-409f-957d-1086d9b01afb®ClientIdÅ¢IdŸ4Microsoft.VisualStudio.Conversations.Chat.HelpWindowßRequestÅßRequestïŸ$2363cde2-6c6a-4ff5-852d-0a4dd95423f1Ÿ$5b5fa0a1-3bfa-4ac9-a104-033fa40037ccëÜØProviderMonikerÇ§NameŸ6Microsoft.VisualStudio.Copilot.DocumentContextProviderßVersion£0.1¶Member§file©CanReduce√©RequestIdŸ$2363cde2-6c6a-4ff5-852d-0a4dd95423f1©Reference¿•Value»ÉádŸëMicrosoft.VisualStudio.Copilot.DocumentContext, Microsoft.VisualStudio.Copilot, Version=0.2.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3aÖßContent⁄Ç$using Emgu.CV;
using Emgu.CV.CvEnum;
using Emgu.CV.Util;
using Python.Runtime;
using System.Drawing;

namespace Minor_Project_Ai_Plant_Recognition.SorceCode.Preprocessing
{
    /// <summary>
    /// This class is responsible for parsing images from the given directory path.
    /// It writes the paths of the images to a text file.
    /// </summary>
    internal class ImageAccess
    {
        /// <summary>
        /// Parses the directories for image files and writes their paths to a text file.
        /// </summary>
        /// <param name="path">The base path of the directories.</param>
        /// <param name="pathTextFile">The path of the text file to write to.</param>
        public void DirectoryParser(string path, string pathTextFile, string action)
        {
            string[] directories;
            List<string> directoriesList = pathMakerBasedOnAction(path, action);
            directories = directoriesList.ToArray();

            Directory.CreateDirectory(pathTextFile);

            if (action == "Augment" || action == "BckgrndRemove" || action == "Normalization")
            {
                DirParserByImgDim(directories, pathTextFile);
            }
            else if (action == "Resize" || action == "parse")
            {
                DirParserByClass(directories, pathTextFile);
            }
            else
            {
                throw new ArgumentOutOfRangeException($"The action '{action}' does not exist.");
            }
        }

        public void DirParserByClass(string[] directories, string pathTextFile)
        {
            if (File.Exists(Path.Combine(pathTextFile, "dataset_base.txt")))
            {
                File.Delete(Path.Combine(pathTextFile, "dataset_base.txt"));
            }
            using (StreamWriter writer = new(Path.Combine(pathTextFile, "dataset_base.txt"), true))
            {
                foreach (string directory in directories)
                {
                    if (!Directory.Exists(directory))
                    {
                        throw new DirectoryNotFoundException($"The directory '{directory}' does not exist.");
                    }

                    foreach (string subdirectory in Directory.EnumerateDirectories(directory))
                    {
                        foreach (string filePath in Directory.EnumerateFiles(subdirectory))
                        {
                            string extension = Path.GetExtension(filePath);
                            if (extension == ".jpg" || extension == ".png")
                            {
                                writer.WriteLine(filePath);
                            }
                        }
                    }
                }
            }
        }

        public void DirParserByImgDim(string[] directories, string pathTextFile)
        {
            //using (StreamWriter writer = new(Path.Combine(pathTextFile, $"dataset_.{parentName}txt"), false))
            if (File.Exists(Path.Combine(pathTextFile, $"dataset_size224_224.txt")))
            {
                File.Delete(Path.Combine(pathTextFile, $"dataset_size224_224.txt"));
            }
            if (File.Exists(Path.Combine(pathTextFile, $"dataset_size299_299.txt")))
            {
                File.Delete(Path.Combine(pathTextFile, $"dataset_size299_299.txt"));
            }

            foreach (string directory in directories)
            {
                if (new DirectoryInfo(directory).Parent!.Name == "size224_224")
                {
                    if (!Directory.Exists(directory))
                    {
                        throw new DirectoryNotFoundException($"The directory '{directory}' does not exist.");
                    }
                    using (StreamWriter writer = new(Path.Combine(pathTextFile, $"dataset_size224_224.txt"), true))
                    {
                        foreach (string subdirectory in Directory.EnumerateDirectories(directory))
                        {
                            foreach (string filePath in Directory.EnumerateFiles(subdirectory))
                            {
                                string extension = Path.GetExtension(filePath);
                                if (extension == ".jpg" || extension == ".png")
                                {
                                    writer.WriteLine(filePath);
                                }
                            }
                        }
                    }
                }
                else if (new DirectoryInfo(directory).Parent!.Name == "size299_299")
                {
                    if (!Directory.Exists(directory))
                    {
                        throw new DirectoryNotFoundException($"The directory '{directory}' does not exist.");
                    }
                    using (StreamWriter writer = new(Path.Combine(pathTextFile, $"dataset_size299_299.txt"), true))
                    {
                        foreach (string subdirectory in Directory.EnumerateDirectories(directory))
                        {
                            foreach (string filePath in Directory.EnumerateFiles(subdirectory))
                            {
                                string extension = Path.GetExtension(filePath);
                                if (extension == ".jpg" || extension == ".png")
                                {
                                    writer.WriteLine(filePath);
                                }
                            }
                        }
                    }
                }
                else
                {
                    throw new DirectoryNotFoundException($"The directory does not exist.");
                }
            }
        }

        /// <summary>
        /// Constructs a list of directories based on the specified action.
        /// </summary>
        /// <param name="path">The base path to use when constructing the directories.</param>
        /// <param name="action">The action to base the directories on. Can be "resize", "parse", or "Augment".</param>
        /// <returns>A list of directories constructed based on the specified action.</returns>
        public List<string> pathMakerBasedOnAction(string path, string action)
        {
            List<string> directories = new List<string>();
            List<string> tempDir = new List<string>();

            if (action == "Resize" || action == "parse")
            {
                directories.Add(Path.Combine(path, "Medicinal_Leaf_dataset"));
                directories.Add(Path.Combine(path, "Medicinal_plant_dataset"));
            }
            else if (action == "Augment")
            {
                tempDir.Add(Path.Combine(path, "size224_224"));
                tempDir.Add(Path.Combine(path, "size299_299"));

                foreach (string dir in tempDir.ToList()) // Use ToList to create a copy for iteration
                {
                    directories.AddRange(pathMakerBasedOnAction(dir, "parse"));
                }
            }
            else if (action == "BckgrndRemove")
            {
                List<string> dirNames = new List<string> { "flipped", "noised", "resized", "rotated", "translated" };
                List<string> dimension = new List<string> { "size224_224", "size299_299" };
                foreach (string dirName in dirNames)
                {
                    foreach (string dim in dimension)
                    {
                        tempDir.Add(Path.Combine(path, dirName, dim));
                    }
                }

                foreach (string dir in tempDir.ToList()) // Use ToList to create a copy for iteration
                {
                    directories.AddRange(pathMakerBasedOnAction(dir, "parse"));
                }
            }
            else if (action == "Normalization")
            {
                List<string> dirNames = new List<string> { "flipped", "noised", "resized", "rotated", "translated" };
                List<string> dimension = new List<string> { "size224_224", "size299_299" };
                foreach (string dirName in dirNames)
                {
                    foreach (string dim in dimension)
                    {
                        tempDir.Add(Path.Combine(path, dirName, dim));
                    }
                }

                foreach (string dir in tempDir.ToList()) // Use ToList to create a copy for iteration
                {
                    directories.AddRange(pathMakerBasedOnAction(dir, "parse"));
                }
            }
            return directories;
        }
    }

    /// <summary>
    /// This class is responsible for writing images to a directory.
    /// </summary>
    internal class NewImageWrite
    {
        /// <summary>
        /// Creates a directory and writes an image to it.
        /// </summary>
        /// <param name="path">The path of the directory to create.</param>
        /// <param name="newImg">The image to write.</param>
        /// <param name="imgName">The name of the image file.</param>
        public static void DirrectoryCreate(string path, Mat newImg, string imgName)
        {
            if (!Directory.Exists(path))
            {
                try
                {
                    Directory.CreateDirectory(path);
                }
                catch (Exception e)
                {
                    Console.WriteLine($"Failed to create directory: {e}");
                }
            }

            WriteImage(path, newImg, imgName);
        }

        /// <summary>
        /// Writes an image to a file.
        /// </summary>
        /// <param name="path">The path of the file to write to.</param>
        /// <param name="newImg">The image to write.</param>
        /// <param name="imgName">The name of the image file.</param>
        private static void WriteImage(string path, Mat newImg, string imgName)
        {
            string newPath = Path.Combine(path, imgName);

            try
            {
                CvInvoke.Imwrite(newPath, newImg);
            }
            catch (IOException e)
            {
                Console.WriteLine("In NewImageWriter");
                Console.WriteLine($"Failed to write image: {e}");
            }
        }
    }

    /// <summary>
    /// This class is responsible for resizing images.
    /// </summary>
    internal class ImageResize
    {
        /// <summary>
        /// The directory to output the resized images to.
        /// </summary>
        public string OutputDirectory { get; } = "D:\\Project\\AI_ML_DS\\Minor_Project_Ai_Plant_Recognition\\Minor_Project_Ai_Plant_Recognition\\Data\\Dataset(resized)";

        private readonly NewImageWrite _newImageWrite = new NewImageWrite();

        /// <summary>
        /// Resizes the images specified in the text file at the given path.
        /// </summary>
        /// <param name="path">The path of the text file containing the image paths.</param>
        public void ResizeFactory(string path)
        {
            string textPath = Path.Combine(path, "dataset_base.txt");

            ResizeDirectory(textPath, 224, 224);
            ResizeDirectory(textPath, 299, 299);
        }

        public void ResizeDirectory(string path, int width, int height)
        {
            var lines = File.ReadLines(path);
            Parallel.ForEach(lines, (line) =>
            {
                Resizer(line, width, height);
            });
        }

        /// <summary>
        /// Resizes an image to the specified width and height.
        /// </summary>
        /// <param name="path">The path of the image to resize.</param>
        /// <param name="width">The width to resize to.</param>
        /// <param name="height">The height to resize to.</param>
        private void Resizer(string path, int width, int height)
        {
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);
            Mat resizedImage = new Mat();
            CvInvoke.Resize(image, resizedImage, new Size(width, height), 0, 0, Inter.Area);

            ImageWriterAssistance(path, resizedImage, width, height);
        }

        /// <summary>
        /// Assists in writing the resized image to the output directory.
        /// </summary>
        /// <param name="path">The path of the original image.</param>
        /// <param name="newImg">The resized image.</param>
        /// <param name="width">The width of the resized image.</param>
        /// <param name="height">The height of the resized image.</param>
        private void ImageWriterAssistance(string path, Mat newImg, int width, int height)
        {
            DirectoryInfo? dirParentInfo = new DirectoryInfo(path).Parent?.Parent;
            DirectoryInfo? dirInfo = new DirectoryInfo(path).Parent;
            string? dirName = dirInfo?.Name!;
            string? dirParentName = dirParentInfo?.Name!;
            string imgName = Path.GetFileName(path);
            string specificOutputDirectory = Path.Combine(OutputDirectory, $"size{width}_{height}", dirParentName, dirName);

            NewImageWrite.DirrectoryCreate(specificOutputDirectory, newImg, imgName);
        }
    }

    /// <summary>
    /// This class is responsible for Data Augmentation.
    /// </summary>
    internal class DataAugmentation
    {
        private readonly NewImageWrite _newImageWrite = new NewImageWrite();

        /// <summary>
        /// Augments the images specified in the text file at the given path.
        /// </summary>
        /// <param name="path">The path of the text file containing the image paths.</param>
        public void AugmentFactory(string path)
        {
            string path224 = Path.Combine(path, "dataset_size224_224.txt");
            string path299 = Path.Combine(path, "dataset_size299_299.txt");

            Task path224Task = Task.Run(() => AugmentDirectory(path224, "224Task"));
            Task path299Task = Task.Run(() => AugmentDirectory(path299, "299Task"));

            Task.WaitAll(path224Task, path299Task);
        }

        public void AugmentDirectory(string path, string taskName)
        {
            if (taskName == "224Task")
            {
                int totalLines = File.ReadLines(path).Count();
                {
                    using (StreamReader reader = new StreamReader(path))
                    {
                        string line;
                        while ((line = reader.ReadLine()!) != null)
                        {
                            FlipAugmenter(line);
                            RotateAugmenter(line);
                            NoiseAugmenter(line);
                            TranslateAugmenter(line);
                            CopyResizedImage(line);
                        }
                    }
                }
            }
            else if (taskName == "299Task")
            {
                int totalLines = File.ReadLines(path).Count();
                {
                    using (StreamReader reader = new StreamReader(path))
                    {
                        string line;
                        while ((line = reader.ReadLine()!) != null)
                        {
                            FlipAugmenter(line);
                            RotateAugmenter(line);
                            NoiseAugmenter(line);
                            TranslateAugmenter(line);
                            CopyResizedImage(line);
                        }
                    }
                }
            }
            else
            {
                throw new ArgumentOutOfRangeException($"The task '{taskName}' does not exist.");
            }
        }

        /// <summary>
        /// Augments an image by flipping it.
        /// </summary>
        /// <param name="path">The path of the image to augment.</param>
        private void FlipAugmenter(string path)
        {
            string action = "flipped";
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);
            Mat flippedImage = new Mat();
            CvInvoke.Flip(image, flippedImage, FlipType.Both);

            ImageWriterAssistance(path, flippedImage, action);
        }

        /// <summary>
        /// Augments an image by rotating it.
        /// </summary>
        /// <param name="path">The path of the image to augment.</param>
        private void RotateAugmenter(string path)
        {
            string action = "rotated";
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);
            Mat rotatedImage = new Mat();
            CvInvoke.Rotate(image, rotatedImage, RotateFlags.Rotate90Clockwise);

            ImageWriterAssistance(path, rotatedImage, action);
        }

        /// <summary>
        /// Augments an image by adding noise to it.
        /// </summary>
        /// <param name="path">The path of the image to augment.</param>
        private void NoiseAugmenter(string path)
        {
            string action = "noised";
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);
            Mat noisedImage = new Mat();
            CvInvoke.GaussianBlur(image, noisedImage, new Size(5, 5), 0);

            ImageWriterAssistance(path, noisedImage, action);
        }

        /// <summary>
        /// Augments an image by translating it.
        /// </summary>
        /// <param name="path">The path of the image to augment.</param>
        private void TranslateAugmenter(string path)
        {
            string action = "translated";
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);
            int imageWidth = image.Width;
            int imageHeight = image.Height;
            Mat translatedImage = new Mat();
            Matrix<float> shiftMatrix = new Matrix<float>(2, 3);
            Random rand = new Random();
            int shiftX = rand.Next(-50, 50);  // Random shift in x direction between -50 and 50
            int shiftY = rand.Next(-50, 50);  // Random shift in y direction between -50 and 50

            shiftMatrix[0, 0] = 1;  // Identity element
            shiftMatrix[1, 1] = 1;  // Identity element
            shiftMatrix[0, 2] = shiftX;  // Shift in x direction
            shiftMatrix[1, 2] = shiftY;  // Shift in y direction
            CvInvoke.WarpAffine(image, translatedImage, shiftMatrix, new Size(imageWidth, imageHeight), 0);

            ImageWriterAssistance(path, translatedImage, action);
        }

        /// <summary>
        /// Augments an image by copying it to the output directory.
        /// </summary>
        /// <param name="path"></param>
        private void CopyResizedImage(string path)
        {
            string action = "resized";
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);
            Mat copyResizedImage = image;

            ImageWriterAssistance(path, copyResizedImage, action);
        }

        /// <summary>
        /// The directory to output the augmented images to.
        /// </summary>
        public string OutputDirectory { get; } = "D:\\Project\\AI_ML_DS\\Minor_Project_Ai_Plant_Recognition\\Minor_Project_Ai_Plant_Recognition\\Data\\Dataset(augmented)";

        /// <summary>
        /// Assists in writing the augmented image to the output directory.
        /// </summary>
        /// <param name="path">The path of the original image.</param>
        /// <param name="newImg">The augmented image.</param>
        private void ImageWriterAssistance(string path, Mat newImg, string action)
        {
            DirectoryInfo? directoryParentParentInfo = new DirectoryInfo(path).Parent?.Parent?.Parent;
            DirectoryInfo? dirParentInfo = new DirectoryInfo(path).Parent?.Parent;
            DirectoryInfo? dirInfo = new DirectoryInfo(path).Parent;
            string? dirName = dirInfo?.Name!;
            string? dirParentName = dirParentInfo?.Name!;
            string? dirParentParentName = directoryParentParentInfo?.Name!;
            string imgName = Path.GetFileName(path);
            string specificOutputDirectory = Path.Combine(OutputDirectory, action, dirParentParentName, dirParentName, dirName);

            NewImageWrite.DirrectoryCreate(specificOutputDirectory, newImg, imgName);
        }
    }

    /// <summary>
    /// This class is responsible for removing the background from images.
    /// </summary>
    internal class BckgrndRemover
    {
        private readonly NewImageWrite _newImageWrite = new NewImageWrite();

        /// <summary>
        /// Removes the background from the images specified in the text file at the given path.
        /// </summary>
        /// <param name="path">The path of the text file containing the image paths.</param>
        public void RemoveBackgroundFactory(string path)
        {
            string path224 = Path.Combine(path, "dataset_size224_224.txt");
            string path299 = Path.Combine(path, "dataset_size299_299.txt");

            Task path224Task = Task.Run(() => BackGrndRemoveDirectory(path224, "224Task"));
            Task path299Task = Task.Run(() => BackGrndRemoveDirectory(path299, "299Task"));

            Task.WaitAll(path224Task, path299Task);
            //// Path to the Python DLL
            //Runtime.PythonDLL = @"C:\Users\kumar\AppData\Local\Programs\Python\Python312\python312.dll";
            //// Setting the PYTHONHOME environment variable
            //Environment.SetEnvironmentVariable("PYTHONHOME", @"C:\Users\kumar\AppData\Local\Programs\Python\Python312", EnvironmentVariableTarget.Process);

            //try
            //{
            //    // Initialize the Python Engine
            //    PythonEngine.Initialize();

            //    int totalLines = File.ReadLines(Path.Combine(path, "dataset.txt")).Count();
            //    using (var pbar = new ProgressBar(totalLines, "Removing Background", new ProgressBarOptions { ProgressCharacter = '#' }))
            //    {
            //        using (StreamReader reader = new StreamReader(Path.Combine(path, "dataset.txt")))
            //        {
            //            string line;
            //            while ((line = reader.ReadLine()!) != null)
            //            {
            //                PythonScriptRemoveBackground(line);
            //                pbar.Tick();
            //            }
            //        }
            //    }
            //}
            //catch (Exception e)
            //{
            //    Console.WriteLine($"Failed to remove background: {e.Message}");
            //}
            //finally
            //{
            //    // Shutdown the Python Engine
            //    PythonEngine.Shutdown();
            //}
        }

        private void BackGrndRemoveDirectory(string path, string taskName)
        {
            // Path to the Python DLL
            Runtime.PythonDLL = @"C:\Users\kumar\AppData\Local\Programs\Python\Python312\python312.dll";
            // Setting the PYTHONHOME environment variable
            Environment.SetEnvironmentVariable("PYTHONHOME", @"C:\Users\kumar\AppData\Local\Programs\Python\Python312", EnvironmentVariableTarget.Process);

            try
            {
                PythonEngine.Initialize();

                if (taskName == "224Task")
                {
                    int totalLines = File.ReadLines(path).Count();
                    {
                        using (StreamReader reader = new StreamReader(path))
                        {
                            string line;
                            while ((line = reader.ReadLine()!) != null)
                            {
                                PythonScriptRemoveBackground(line);
                            }
                        }
                    }
                }
                else if (taskName == "299Task")
                {
                    int totalLines = File.ReadLines(path).Count();
                    {
                        using (StreamReader reader = new StreamReader(path))
                        {
                            string line;
                            while ((line = reader.ReadLine()!) != null)
                            {
                                PythonScriptRemoveBackground(line);
                            }
                        }
                    }
                }
                else
                {
                    throw new ArgumentOutOfRangeException($"The task '{taskName}' does not exist.");
                }
            }
            catch (Exception e)
            {
                Console.WriteLine($"Failed to remove background: {e.Message}");
            }
            finally
            {
                // Shutdown the Python Engine
                PythonEngine.Shutdown();
            }
        }

        /// <summary>
        /// Executes a Python script to remove the background from an image.
        /// </summary>
        /// <param name="path">The path of the image to process.</param>
        private void PythonScriptRemoveBackground(string path)
        {
            using (Py.GIL())
            {
                // Get the output path for the processed image
                string outputPath = ImageWriterAssistance(path);

                // Read the Python script
                string pythonScript = System.IO.File.ReadAllText(@"D:\Project\AI_ML_DS\Minor_Project_Ai_Plant_Recognition\Minor_Project_Ai_Plant_Recognition\SorceCode\remove_background.py");
                // Run the Python script
                PythonEngine.RunSimpleString(pythonScript);
                // Call the remove_backgrnd function from the Python script
                dynamic removeBackground = PythonEngine.RunSimpleString($"remove_backgrnd(r'{path}', r'{outputPath}')");
            }
        }

        /// <summary>
        /// The directory to output the images with the background removed to.
        /// </summary>
        public string OutputDirectory { get; } = "D:\\Project\\AI_ML_DS\\Minor_Project_Ai_Plant_Recognition\\Minor_Project_Ai_Plant_Recognition\\Data\\Dataset(background_removed)";

        /// <summary>
        /// Assists in writing the image with the background removed to the output directory.
        /// </summary>
        /// <param name="path">The path of the original image.</param>
        /// <param name="newImg">The image with the background removed.</param>
        private string ImageWriterAssistance(string path)
        {
            DirectoryInfo? dirParentParentParentInfo = new DirectoryInfo(path).Parent?.Parent?.Parent?.Parent;
            DirectoryInfo? dirParentParentInfo = new DirectoryInfo(path).Parent?.Parent?.Parent;
            DirectoryInfo? dirParentInfo = new DirectoryInfo(path).Parent?.Parent;
            DirectoryInfo? dirInfo = new DirectoryInfo(path).Parent;
            string? dirName = dirInfo?.Name!;
            string? dirParentName = dirParentInfo?.Name!;
            string? dirParentParentName = dirParentParentInfo?.Name!;
            string? dirParentParentParentName = dirParentParentParentInfo?.Name!;
            string imgName = Path.GetFileName(path);
            string specificOutputDirectory = Path.Combine(OutputDirectory, dirParentParentParentName, dirParentParentName, dirParentName, dirName);

            return Path.Combine(specificOutputDirectory, imgName);
            // Regular image write is not needed.
            //_newImageWrite.DirrectoryCreate(specificOutputDirectory, newImg, imgName);
        }
    }

    /// <summary>
    /// This class is responsble for normalization of images data.
    /// </summary>
    internal class Normalization
    {
        private readonly NewImageWrite _newImageWrite = new NewImageWrite();

        /// <summary>
        /// Normalizes the images specified in the text file at the given path.
        /// </summary>
        /// <param name="path">The path of the text file containing the image paths.</param>
        public void NormalizationFactor(string path)
        {
            string path224 = Path.Combine(path, "dataset_size224_224.txt");
            string path299 = Path.Combine(path, "dataset_size299_299.txt");

            Task path224Task = Task.Run(() => NormalizeDirectory(path224, "224Task"));
            Task path299Task = Task.Run(() => NormalizeDirectory(path299, "299Task"));

            Task.WaitAll(path224Task, path299Task);
            //int totalLines = File.ReadLines(Path.Combine(path, "dataset.txt")).Count();

            //using (var pbar = new ProgressBar(totalLines, "Resizing", new ProgressBarOptions { ProgressCharacter = '#' }))
            //{
            //    using (StreamReader reader = new StreamReader(Path.Combine(path, "dataset.txt")))
            //    {
            //        string line;
            //        while ((line = reader.ReadLine()!) != null)
            //        {
            //            NormalizeColorWise(line);
            //            pbar.Tick();
            //        }
            //    }
            //}
        }

        private void NormalizeDirectory(string path, string taskName)
        {
            if (taskName == "224Task")
            {
                int totalLines = File.ReadLines(path).Count();
                {
                    using (StreamReader reader = new StreamReader(path))
                    {
                        string line;
                        while ((line = reader.ReadLine()!) != null)
                        {
                            NormalizeColorWise(line);
                        }
                    }
                }
            }
            else if (taskName == "299Task")
            {
                int totalLines = File.ReadLines(path).Count();
                {
                    using (StreamReader reader = new StreamReader(path))
                    {
                        string line;
                        while ((line = reader.ReadLine()!) != null)
                        {
                            NormalizeColorWise(line);
                        }
                    }
                }
            }
            else
            {
                throw new ArgumentOutOfRangeException($"The task '{taskName}' does not exist.");
            }
        }

        /// <summary>
        /// Normalizes an image using min-max.
        /// </summary>
        /// <param name="path">The path of the image to process.</param>
        public void NormalizeColorWise(string path)
        {
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);

            Mat normalizedImage = image.Clone();
            VectorOfMat vm = new VectorOfMat();
            CvInvoke.Split(image, vm);

            for (int i = 0; i < vm.Size; i++)
            {
                Mat channel = vm[i];
                CvInvoke.Normalize(channel, channel, 0, 255, NormType.MinMax);
            }
            CvInvoke.Merge(vm, normalizedImage);

            ImageWriterAssistance(path, normalizedImage);
        }

        /// <summary>
        /// The directory to output the normalized images to the directory.
        /// </summary>
        public string OutputDirectory { get; } = "D:\\Project\\AI_ML_DS\\Minor_Project_Ai_Plant_Recognition\\Minor_Project_Ai_Plant_Recognition\\Data\\Dataset(normalized)";

        /// <summary>
        /// Assists in writing the normalized image to the output directory.
        /// </summary>
        /// <param name="path">The path of the original image.</param>
        /// <param name="newImg">The image with the background removed.</param>

        private void ImageWriterAssistance(string path, Mat newImg)
        {
            DirectoryInfo? dirParentParentParentInfo = new DirectoryInfo(path).Parent?.Parent?.Parent?.Parent;
            DirectoryInfo? dirParentParentInfo = new DirectoryInfo(path).Parent?.Parent?.Parent;
            DirectoryInfo? dirParentInfo = new DirectoryInfo(path).Parent?.Parent;
            DirectoryInfo? dirInfo = new DirectoryInfo(path).Parent;
            string? dirName = dirInfo?.Name!;
            string? dirParentName = dirParentInfo?.Name!;
            string? dirParentParentName = dirParentParentInfo?.Name!;
            string? dirParentParentParentName = dirParentParentParentInfo?.Name!;
            string imgName = Path.GetFileName(path);
            string specificOutputDirectory = Path.Combine(OutputDirectory, dirParentParentParentName, dirParentParentName, dirParentName, dirName);

            NewImageWrite.DirrectoryCreate(specificOutputDirectory, newImg, imgName);
        }
    }
}ØOriginalContent¿™SelectionsëÉ•Caret¿•StartÕ\Ö£EndÕaÙ®FilePathŸxD:\Project\AI_ML_DS\Minor_Project_Ai_Plant_Recognition\Minor_Project_Ai_Plant_Recognition\SorceCode\DataPreprocessing.cs®Language¢C#ëíìÅ•Value ßin here¿®ResponseÖßContent⁄ÈYes, you can initialize the Python engine in a separate thread, but you need to ensure that the Python engine is initialized before you use any Python-related functionality in your threads. 

However, in your case, you are using the Python engine in the main thread, not in a separate thread. So, you can initialize the Python engine at the start of your method like this:

```csharp
try
{
    if (!PythonEngine.IsInitialized)
    {
        PythonEngine.Initialize();
    }

    // rest of your code
}
```

This code checks if the Python engine is already initialized using the `PythonEngine.IsInitialized` property. If it's not, it initializes it using the `PythonEngine.Initialize` method.

Remember, Python's Global Interpreter Lock (GIL) ensures that only one thread executes Python bytecode at a time. So, if you are planning to use Python in multiple threads, you need to manage the GIL properly. You can use `PythonEngine.BeginAllowThreads` and `PythonEngine.EndAllowThreads` to manage the GIL.§Type ¶StatusØFollowUpPromptsíŸYHow can I manage the Global Interpreter Lock (GIL) when using Python in multiple threads?ŸzCan you provide an example of using `PythonEngine.BeginAllowThreads` and `PythonEngine.EndAllowThreads` to manage the GIL?≥CodeVulnerabilitiesê∂LoggedSkillInvocations¿Ü®DateTime◊ˇ?π¨ f(¥Î™ThreadName¿∞CopilotSessionIdÇ§GuidŸ$64b71c8f-ffb9-409f-957d-1086d9b01afb®ClientIdÅ¢IdŸ4Microsoft.VisualStudio.Conversations.Chat.HelpWindowßRequestÅßRequestïŸ$7141cb3f-c446-49b6-803c-c925e8b18344Ÿ$e806f5c6-7f35-4146-a3a4-a23f4583b970êëíìÅ•Value Ÿ6its throwing error. attempt to access protected memory¿®ResponseÖßContent⁄∑The error "Attempted to read or write protected memory" often occurs when there's an attempt to access memory that is not allocated, or it has been disposed of. This is common when dealing with unmanaged resources or interop services.

In your case, it seems like you're using Emgu.CV and Python.Runtime, both of which use unmanaged resources. The error might be due to improper handling of these resources.

Here are a few things you can try:

1. Ensure that you're not trying to access an object after it's been disposed of. For example, if you're using a `Mat` object after calling `Dispose` on it, you'll get this error.

2. If you're using multithreading, make sure that you're not accessing shared resources concurrently from multiple threads. You might need to use locks to synchronize access to shared resources.

3. If you're using Python.Runtime, make sure that you're managing the Python Global Interpreter Lock (GIL) correctly. You need to acquire the GIL before you use any Python objects, and release it when you're done.

Without seeing the exact line of code that's causing the error, it's hard to give a more specific solution. But these general tips should help you troubleshoot the issue.§Type ¶StatusØFollowUpPromptsê≥CodeVulnerabilitiesê∂LoggedSkillInvocations¿Ü®DateTime◊ˇéï0f(µ;™ThreadName¿∞CopilotSessionIdÇ§GuidŸ$64b71c8f-ffb9-409f-957d-1086d9b01afb®ClientIdÅ¢IdŸ4Microsoft.VisualStudio.Conversations.Chat.HelpWindowßRequestÅßRequestïŸ$87d5164d-0e69-4d23-91a3-3cbe6a2b4b25Ÿ$04318d4f-35f8-42c9-aa53-eed02d3e55f0ëÜØProviderMonikerÇ§NameŸ6Microsoft.VisualStudio.Copilot.DocumentContextProviderßVersion£0.1¶Member§file©CanReduce√©RequestIdŸ$87d5164d-0e69-4d23-91a3-3cbe6a2b4b25©Reference¿•Value»ÉádŸëMicrosoft.VisualStudio.Copilot.DocumentContext, Microsoft.VisualStudio.Copilot, Version=0.2.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3aÖßContent⁄Ç$using Emgu.CV;
using Emgu.CV.CvEnum;
using Emgu.CV.Util;
using Python.Runtime;
using System.Drawing;

namespace Minor_Project_Ai_Plant_Recognition.SorceCode.Preprocessing
{
    /// <summary>
    /// This class is responsible for parsing images from the given directory path.
    /// It writes the paths of the images to a text file.
    /// </summary>
    internal class ImageAccess
    {
        /// <summary>
        /// Parses the directories for image files and writes their paths to a text file.
        /// </summary>
        /// <param name="path">The base path of the directories.</param>
        /// <param name="pathTextFile">The path of the text file to write to.</param>
        public void DirectoryParser(string path, string pathTextFile, string action)
        {
            string[] directories;
            List<string> directoriesList = pathMakerBasedOnAction(path, action);
            directories = directoriesList.ToArray();

            Directory.CreateDirectory(pathTextFile);

            if (action == "Augment" || action == "BckgrndRemove" || action == "Normalization")
            {
                DirParserByImgDim(directories, pathTextFile);
            }
            else if (action == "Resize" || action == "parse")
            {
                DirParserByClass(directories, pathTextFile);
            }
            else
            {
                throw new ArgumentOutOfRangeException($"The action '{action}' does not exist.");
            }
        }

        public void DirParserByClass(string[] directories, string pathTextFile)
        {
            if (File.Exists(Path.Combine(pathTextFile, "dataset_base.txt")))
            {
                File.Delete(Path.Combine(pathTextFile, "dataset_base.txt"));
            }
            using (StreamWriter writer = new(Path.Combine(pathTextFile, "dataset_base.txt"), true))
            {
                foreach (string directory in directories)
                {
                    if (!Directory.Exists(directory))
                    {
                        throw new DirectoryNotFoundException($"The directory '{directory}' does not exist.");
                    }

                    foreach (string subdirectory in Directory.EnumerateDirectories(directory))
                    {
                        foreach (string filePath in Directory.EnumerateFiles(subdirectory))
                        {
                            string extension = Path.GetExtension(filePath);
                            if (extension == ".jpg" || extension == ".png")
                            {
                                writer.WriteLine(filePath);
                            }
                        }
                    }
                }
            }
        }

        public void DirParserByImgDim(string[] directories, string pathTextFile)
        {
            //using (StreamWriter writer = new(Path.Combine(pathTextFile, $"dataset_.{parentName}txt"), false))
            if (File.Exists(Path.Combine(pathTextFile, $"dataset_size224_224.txt")))
            {
                File.Delete(Path.Combine(pathTextFile, $"dataset_size224_224.txt"));
            }
            if (File.Exists(Path.Combine(pathTextFile, $"dataset_size299_299.txt")))
            {
                File.Delete(Path.Combine(pathTextFile, $"dataset_size299_299.txt"));
            }

            foreach (string directory in directories)
            {
                if (new DirectoryInfo(directory).Parent!.Name == "size224_224")
                {
                    if (!Directory.Exists(directory))
                    {
                        throw new DirectoryNotFoundException($"The directory '{directory}' does not exist.");
                    }
                    using (StreamWriter writer = new(Path.Combine(pathTextFile, $"dataset_size224_224.txt"), true))
                    {
                        foreach (string subdirectory in Directory.EnumerateDirectories(directory))
                        {
                            foreach (string filePath in Directory.EnumerateFiles(subdirectory))
                            {
                                string extension = Path.GetExtension(filePath);
                                if (extension == ".jpg" || extension == ".png")
                                {
                                    writer.WriteLine(filePath);
                                }
                            }
                        }
                    }
                }
                else if (new DirectoryInfo(directory).Parent!.Name == "size299_299")
                {
                    if (!Directory.Exists(directory))
                    {
                        throw new DirectoryNotFoundException($"The directory '{directory}' does not exist.");
                    }
                    using (StreamWriter writer = new(Path.Combine(pathTextFile, $"dataset_size299_299.txt"), true))
                    {
                        foreach (string subdirectory in Directory.EnumerateDirectories(directory))
                        {
                            foreach (string filePath in Directory.EnumerateFiles(subdirectory))
                            {
                                string extension = Path.GetExtension(filePath);
                                if (extension == ".jpg" || extension == ".png")
                                {
                                    writer.WriteLine(filePath);
                                }
                            }
                        }
                    }
                }
                else
                {
                    throw new DirectoryNotFoundException($"The directory does not exist.");
                }
            }
        }

        /// <summary>
        /// Constructs a list of directories based on the specified action.
        /// </summary>
        /// <param name="path">The base path to use when constructing the directories.</param>
        /// <param name="action">The action to base the directories on. Can be "resize", "parse", or "Augment".</param>
        /// <returns>A list of directories constructed based on the specified action.</returns>
        public List<string> pathMakerBasedOnAction(string path, string action)
        {
            List<string> directories = new List<string>();
            List<string> tempDir = new List<string>();

            if (action == "Resize" || action == "parse")
            {
                directories.Add(Path.Combine(path, "Medicinal_Leaf_dataset"));
                directories.Add(Path.Combine(path, "Medicinal_plant_dataset"));
            }
            else if (action == "Augment")
            {
                tempDir.Add(Path.Combine(path, "size224_224"));
                tempDir.Add(Path.Combine(path, "size299_299"));

                foreach (string dir in tempDir.ToList()) // Use ToList to create a copy for iteration
                {
                    directories.AddRange(pathMakerBasedOnAction(dir, "parse"));
                }
            }
            else if (action == "BckgrndRemove")
            {
                List<string> dirNames = new List<string> { "flipped", "noised", "resized", "rotated", "translated" };
                List<string> dimension = new List<string> { "size224_224", "size299_299" };
                foreach (string dirName in dirNames)
                {
                    foreach (string dim in dimension)
                    {
                        tempDir.Add(Path.Combine(path, dirName, dim));
                    }
                }

                foreach (string dir in tempDir.ToList()) // Use ToList to create a copy for iteration
                {
                    directories.AddRange(pathMakerBasedOnAction(dir, "parse"));
                }
            }
            else if (action == "Normalization")
            {
                List<string> dirNames = new List<string> { "flipped", "noised", "resized", "rotated", "translated" };
                List<string> dimension = new List<string> { "size224_224", "size299_299" };
                foreach (string dirName in dirNames)
                {
                    foreach (string dim in dimension)
                    {
                        tempDir.Add(Path.Combine(path, dirName, dim));
                    }
                }

                foreach (string dir in tempDir.ToList()) // Use ToList to create a copy for iteration
                {
                    directories.AddRange(pathMakerBasedOnAction(dir, "parse"));
                }
            }
            return directories;
        }
    }

    /// <summary>
    /// This class is responsible for writing images to a directory.
    /// </summary>
    internal class NewImageWrite
    {
        /// <summary>
        /// Creates a directory and writes an image to it.
        /// </summary>
        /// <param name="path">The path of the directory to create.</param>
        /// <param name="newImg">The image to write.</param>
        /// <param name="imgName">The name of the image file.</param>
        public static void DirrectoryCreate(string path, Mat newImg, string imgName)
        {
            if (!Directory.Exists(path))
            {
                try
                {
                    Directory.CreateDirectory(path);
                }
                catch (Exception e)
                {
                    Console.WriteLine($"Failed to create directory: {e}");
                }
            }

            WriteImage(path, newImg, imgName);
        }

        /// <summary>
        /// Writes an image to a file.
        /// </summary>
        /// <param name="path">The path of the file to write to.</param>
        /// <param name="newImg">The image to write.</param>
        /// <param name="imgName">The name of the image file.</param>
        private static void WriteImage(string path, Mat newImg, string imgName)
        {
            string newPath = Path.Combine(path, imgName);

            try
            {
                CvInvoke.Imwrite(newPath, newImg);
            }
            catch (IOException e)
            {
                Console.WriteLine("In NewImageWriter");
                Console.WriteLine($"Failed to write image: {e}");
            }
        }
    }

    /// <summary>
    /// This class is responsible for resizing images.
    /// </summary>
    internal class ImageResize
    {
        /// <summary>
        /// The directory to output the resized images to.
        /// </summary>
        public string OutputDirectory { get; } = "D:\\Project\\AI_ML_DS\\Minor_Project_Ai_Plant_Recognition\\Minor_Project_Ai_Plant_Recognition\\Data\\Dataset(resized)";

        private readonly NewImageWrite _newImageWrite = new NewImageWrite();

        /// <summary>
        /// Resizes the images specified in the text file at the given path.
        /// </summary>
        /// <param name="path">The path of the text file containing the image paths.</param>
        public void ResizeFactory(string path)
        {
            string textPath = Path.Combine(path, "dataset_base.txt");

            ResizeDirectory(textPath, 224, 224);
            ResizeDirectory(textPath, 299, 299);
        }

        public void ResizeDirectory(string path, int width, int height)
        {
            var lines = File.ReadLines(path);
            Parallel.ForEach(lines, (line) =>
            {
                Resizer(line, width, height);
            });
        }

        /// <summary>
        /// Resizes an image to the specified width and height.
        /// </summary>
        /// <param name="path">The path of the image to resize.</param>
        /// <param name="width">The width to resize to.</param>
        /// <param name="height">The height to resize to.</param>
        private void Resizer(string path, int width, int height)
        {
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);
            Mat resizedImage = new Mat();
            CvInvoke.Resize(image, resizedImage, new Size(width, height), 0, 0, Inter.Area);

            ImageWriterAssistance(path, resizedImage, width, height);
        }

        /// <summary>
        /// Assists in writing the resized image to the output directory.
        /// </summary>
        /// <param name="path">The path of the original image.</param>
        /// <param name="newImg">The resized image.</param>
        /// <param name="width">The width of the resized image.</param>
        /// <param name="height">The height of the resized image.</param>
        private void ImageWriterAssistance(string path, Mat newImg, int width, int height)
        {
            DirectoryInfo? dirParentInfo = new DirectoryInfo(path).Parent?.Parent;
            DirectoryInfo? dirInfo = new DirectoryInfo(path).Parent;
            string? dirName = dirInfo?.Name!;
            string? dirParentName = dirParentInfo?.Name!;
            string imgName = Path.GetFileName(path);
            string specificOutputDirectory = Path.Combine(OutputDirectory, $"size{width}_{height}", dirParentName, dirName);

            NewImageWrite.DirrectoryCreate(specificOutputDirectory, newImg, imgName);
        }
    }

    /// <summary>
    /// This class is responsible for Data Augmentation.
    /// </summary>
    internal class DataAugmentation
    {
        private readonly NewImageWrite _newImageWrite = new NewImageWrite();

        /// <summary>
        /// Augments the images specified in the text file at the given path.
        /// </summary>
        /// <param name="path">The path of the text file containing the image paths.</param>
        public void AugmentFactory(string path)
        {
            string path224 = Path.Combine(path, "dataset_size224_224.txt");
            string path299 = Path.Combine(path, "dataset_size299_299.txt");

            Task path224Task = Task.Run(() => AugmentDirectory(path224, "224Task"));
            Task path299Task = Task.Run(() => AugmentDirectory(path299, "299Task"));

            Task.WaitAll(path224Task, path299Task);
        }

        public void AugmentDirectory(string path, string taskName)
        {
            if (taskName == "224Task")
            {
                int totalLines = File.ReadLines(path).Count();
                {
                    using (StreamReader reader = new StreamReader(path))
                    {
                        string line;
                        while ((line = reader.ReadLine()!) != null)
                        {
                            FlipAugmenter(line);
                            RotateAugmenter(line);
                            NoiseAugmenter(line);
                            TranslateAugmenter(line);
                            CopyResizedImage(line);
                        }
                    }
                }
            }
            else if (taskName == "299Task")
            {
                int totalLines = File.ReadLines(path).Count();
                {
                    using (StreamReader reader = new StreamReader(path))
                    {
                        string line;
                        while ((line = reader.ReadLine()!) != null)
                        {
                            FlipAugmenter(line);
                            RotateAugmenter(line);
                            NoiseAugmenter(line);
                            TranslateAugmenter(line);
                            CopyResizedImage(line);
                        }
                    }
                }
            }
            else
            {
                throw new ArgumentOutOfRangeException($"The task '{taskName}' does not exist.");
            }
        }

        /// <summary>
        /// Augments an image by flipping it.
        /// </summary>
        /// <param name="path">The path of the image to augment.</param>
        private void FlipAugmenter(string path)
        {
            string action = "flipped";
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);
            Mat flippedImage = new Mat();
            CvInvoke.Flip(image, flippedImage, FlipType.Both);

            ImageWriterAssistance(path, flippedImage, action);
        }

        /// <summary>
        /// Augments an image by rotating it.
        /// </summary>
        /// <param name="path">The path of the image to augment.</param>
        private void RotateAugmenter(string path)
        {
            string action = "rotated";
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);
            Mat rotatedImage = new Mat();
            CvInvoke.Rotate(image, rotatedImage, RotateFlags.Rotate90Clockwise);

            ImageWriterAssistance(path, rotatedImage, action);
        }

        /// <summary>
        /// Augments an image by adding noise to it.
        /// </summary>
        /// <param name="path">The path of the image to augment.</param>
        private void NoiseAugmenter(string path)
        {
            string action = "noised";
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);
            Mat noisedImage = new Mat();
            CvInvoke.GaussianBlur(image, noisedImage, new Size(5, 5), 0);

            ImageWriterAssistance(path, noisedImage, action);
        }

        /// <summary>
        /// Augments an image by translating it.
        /// </summary>
        /// <param name="path">The path of the image to augment.</param>
        private void TranslateAugmenter(string path)
        {
            string action = "translated";
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);
            int imageWidth = image.Width;
            int imageHeight = image.Height;
            Mat translatedImage = new Mat();
            Matrix<float> shiftMatrix = new Matrix<float>(2, 3);
            Random rand = new Random();
            int shiftX = rand.Next(-50, 50);  // Random shift in x direction between -50 and 50
            int shiftY = rand.Next(-50, 50);  // Random shift in y direction between -50 and 50

            shiftMatrix[0, 0] = 1;  // Identity element
            shiftMatrix[1, 1] = 1;  // Identity element
            shiftMatrix[0, 2] = shiftX;  // Shift in x direction
            shiftMatrix[1, 2] = shiftY;  // Shift in y direction
            CvInvoke.WarpAffine(image, translatedImage, shiftMatrix, new Size(imageWidth, imageHeight), 0);

            ImageWriterAssistance(path, translatedImage, action);
        }

        /// <summary>
        /// Augments an image by copying it to the output directory.
        /// </summary>
        /// <param name="path"></param>
        private void CopyResizedImage(string path)
        {
            string action = "resized";
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);
            Mat copyResizedImage = image;

            ImageWriterAssistance(path, copyResizedImage, action);
        }

        /// <summary>
        /// The directory to output the augmented images to.
        /// </summary>
        public string OutputDirectory { get; } = "D:\\Project\\AI_ML_DS\\Minor_Project_Ai_Plant_Recognition\\Minor_Project_Ai_Plant_Recognition\\Data\\Dataset(augmented)";

        /// <summary>
        /// Assists in writing the augmented image to the output directory.
        /// </summary>
        /// <param name="path">The path of the original image.</param>
        /// <param name="newImg">The augmented image.</param>
        private void ImageWriterAssistance(string path, Mat newImg, string action)
        {
            DirectoryInfo? directoryParentParentInfo = new DirectoryInfo(path).Parent?.Parent?.Parent;
            DirectoryInfo? dirParentInfo = new DirectoryInfo(path).Parent?.Parent;
            DirectoryInfo? dirInfo = new DirectoryInfo(path).Parent;
            string? dirName = dirInfo?.Name!;
            string? dirParentName = dirParentInfo?.Name!;
            string? dirParentParentName = directoryParentParentInfo?.Name!;
            string imgName = Path.GetFileName(path);
            string specificOutputDirectory = Path.Combine(OutputDirectory, action, dirParentParentName, dirParentName, dirName);

            NewImageWrite.DirrectoryCreate(specificOutputDirectory, newImg, imgName);
        }
    }

    /// <summary>
    /// This class is responsible for removing the background from images.
    /// </summary>
    internal class BckgrndRemover
    {
        private readonly NewImageWrite _newImageWrite = new NewImageWrite();

        /// <summary>
        /// Removes the background from the images specified in the text file at the given path.
        /// </summary>
        /// <param name="path">The path of the text file containing the image paths.</param>
        public void RemoveBackgroundFactory(string path)
        {
            string path224 = Path.Combine(path, "dataset_size224_224.txt");
            string path299 = Path.Combine(path, "dataset_size299_299.txt");

            Task path224Task = Task.Run(() => BackGrndRemoveDirectory(path224, "224Task"));
            Task path299Task = Task.Run(() => BackGrndRemoveDirectory(path299, "299Task"));

            Task.WaitAll(path224Task, path299Task);
            //// Path to the Python DLL
            //Runtime.PythonDLL = @"C:\Users\kumar\AppData\Local\Programs\Python\Python312\python312.dll";
            //// Setting the PYTHONHOME environment variable
            //Environment.SetEnvironmentVariable("PYTHONHOME", @"C:\Users\kumar\AppData\Local\Programs\Python\Python312", EnvironmentVariableTarget.Process);

            //try
            //{
            //    // Initialize the Python Engine
            //    PythonEngine.Initialize();

            //    int totalLines = File.ReadLines(Path.Combine(path, "dataset.txt")).Count();
            //    using (var pbar = new ProgressBar(totalLines, "Removing Background", new ProgressBarOptions { ProgressCharacter = '#' }))
            //    {
            //        using (StreamReader reader = new StreamReader(Path.Combine(path, "dataset.txt")))
            //        {
            //            string line;
            //            while ((line = reader.ReadLine()!) != null)
            //            {
            //                PythonScriptRemoveBackground(line);
            //                pbar.Tick();
            //            }
            //        }
            //    }
            //}
            //catch (Exception e)
            //{
            //    Console.WriteLine($"Failed to remove background: {e.Message}");
            //}
            //finally
            //{
            //    // Shutdown the Python Engine
            //    PythonEngine.Shutdown();
            //}
        }

        private void BackGrndRemoveDirectory(string path, string taskName)
        {
            // Path to the Python DLL
            Runtime.PythonDLL = @"C:\Users\kumar\AppData\Local\Programs\Python\Python312\python312.dll";
            // Setting the PYTHONHOME environment variable
            Environment.SetEnvironmentVariable("PYTHONHOME", @"C:\Users\kumar\AppData\Local\Programs\Python\Python312", EnvironmentVariableTarget.Process);

            try
            {
                PythonEngine.Initialize();

                if (taskName == "224Task")
                {
                    int totalLines = File.ReadLines(path).Count();
                    {
                        using (StreamReader reader = new StreamReader(path))
                        {
                            string line;
                            while ((line = reader.ReadLine()!) != null)
                            {
                                PythonScriptRemoveBackground(line);
                            }
                        }
                    }
                }
                else if (taskName == "299Task")
                {
                    int totalLines = File.ReadLines(path).Count();
                    {
                        using (StreamReader reader = new StreamReader(path))
                        {
                            string line;
                            while ((line = reader.ReadLine()!) != null)
                            {
                                PythonScriptRemoveBackground(line);
                            }
                        }
                    }
                }
                else
                {
                    throw new ArgumentOutOfRangeException($"The task '{taskName}' does not exist.");
                }
            }
            catch (Exception e)
            {
                Console.WriteLine($"Failed to remove background: {e.Message}");
            }
            finally
            {
                // Shutdown the Python Engine
                PythonEngine.Shutdown();
            }
        }

        /// <summary>
        /// Executes a Python script to remove the background from an image.
        /// </summary>
        /// <param name="path">The path of the image to process.</param>
        private void PythonScriptRemoveBackground(string path)
        {
            using (Py.GIL())
            {
                // Get the output path for the processed image
                string outputPath = ImageWriterAssistance(path);

                // Read the Python script
                string pythonScript = System.IO.File.ReadAllText(@"D:\Project\AI_ML_DS\Minor_Project_Ai_Plant_Recognition\Minor_Project_Ai_Plant_Recognition\SorceCode\remove_background.py");
                // Run the Python script
                PythonEngine.RunSimpleString(pythonScript);
                // Call the remove_backgrnd function from the Python script
                dynamic removeBackground = PythonEngine.RunSimpleString($"remove_backgrnd(r'{path}', r'{outputPath}')");
            }
        }

        /// <summary>
        /// The directory to output the images with the background removed to.
        /// </summary>
        public string OutputDirectory { get; } = "D:\\Project\\AI_ML_DS\\Minor_Project_Ai_Plant_Recognition\\Minor_Project_Ai_Plant_Recognition\\Data\\Dataset(background_removed)";

        /// <summary>
        /// Assists in writing the image with the background removed to the output directory.
        /// </summary>
        /// <param name="path">The path of the original image.</param>
        /// <param name="newImg">The image with the background removed.</param>
        private string ImageWriterAssistance(string path)
        {
            DirectoryInfo? dirParentParentParentInfo = new DirectoryInfo(path).Parent?.Parent?.Parent?.Parent;
            DirectoryInfo? dirParentParentInfo = new DirectoryInfo(path).Parent?.Parent?.Parent;
            DirectoryInfo? dirParentInfo = new DirectoryInfo(path).Parent?.Parent;
            DirectoryInfo? dirInfo = new DirectoryInfo(path).Parent;
            string? dirName = dirInfo?.Name!;
            string? dirParentName = dirParentInfo?.Name!;
            string? dirParentParentName = dirParentParentInfo?.Name!;
            string? dirParentParentParentName = dirParentParentParentInfo?.Name!;
            string imgName = Path.GetFileName(path);
            string specificOutputDirectory = Path.Combine(OutputDirectory, dirParentParentParentName, dirParentParentName, dirParentName, dirName);

            return Path.Combine(specificOutputDirectory, imgName);
            // Regular image write is not needed.
            //_newImageWrite.DirrectoryCreate(specificOutputDirectory, newImg, imgName);
        }
    }

    /// <summary>
    /// This class is responsble for normalization of images data.
    /// </summary>
    internal class Normalization
    {
        private readonly NewImageWrite _newImageWrite = new NewImageWrite();

        /// <summary>
        /// Normalizes the images specified in the text file at the given path.
        /// </summary>
        /// <param name="path">The path of the text file containing the image paths.</param>
        public void NormalizationFactor(string path)
        {
            string path224 = Path.Combine(path, "dataset_size224_224.txt");
            string path299 = Path.Combine(path, "dataset_size299_299.txt");

            Task path224Task = Task.Run(() => NormalizeDirectory(path224, "224Task"));
            Task path299Task = Task.Run(() => NormalizeDirectory(path299, "299Task"));

            Task.WaitAll(path224Task, path299Task);
            //int totalLines = File.ReadLines(Path.Combine(path, "dataset.txt")).Count();

            //using (var pbar = new ProgressBar(totalLines, "Resizing", new ProgressBarOptions { ProgressCharacter = '#' }))
            //{
            //    using (StreamReader reader = new StreamReader(Path.Combine(path, "dataset.txt")))
            //    {
            //        string line;
            //        while ((line = reader.ReadLine()!) != null)
            //        {
            //            NormalizeColorWise(line);
            //            pbar.Tick();
            //        }
            //    }
            //}
        }

        private void NormalizeDirectory(string path, string taskName)
        {
            if (taskName == "224Task")
            {
                int totalLines = File.ReadLines(path).Count();
                {
                    using (StreamReader reader = new StreamReader(path))
                    {
                        string line;
                        while ((line = reader.ReadLine()!) != null)
                        {
                            NormalizeColorWise(line);
                        }
                    }
                }
            }
            else if (taskName == "299Task")
            {
                int totalLines = File.ReadLines(path).Count();
                {
                    using (StreamReader reader = new StreamReader(path))
                    {
                        string line;
                        while ((line = reader.ReadLine()!) != null)
                        {
                            NormalizeColorWise(line);
                        }
                    }
                }
            }
            else
            {
                throw new ArgumentOutOfRangeException($"The task '{taskName}' does not exist.");
            }
        }

        /// <summary>
        /// Normalizes an image using min-max.
        /// </summary>
        /// <param name="path">The path of the image to process.</param>
        public void NormalizeColorWise(string path)
        {
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);

            Mat normalizedImage = image.Clone();
            VectorOfMat vm = new VectorOfMat();
            CvInvoke.Split(image, vm);

            for (int i = 0; i < vm.Size; i++)
            {
                Mat channel = vm[i];
                CvInvoke.Normalize(channel, channel, 0, 255, NormType.MinMax);
            }
            CvInvoke.Merge(vm, normalizedImage);

            ImageWriterAssistance(path, normalizedImage);
        }

        /// <summary>
        /// The directory to output the normalized images to the directory.
        /// </summary>
        public string OutputDirectory { get; } = "D:\\Project\\AI_ML_DS\\Minor_Project_Ai_Plant_Recognition\\Minor_Project_Ai_Plant_Recognition\\Data\\Dataset(normalized)";

        /// <summary>
        /// Assists in writing the normalized image to the output directory.
        /// </summary>
        /// <param name="path">The path of the original image.</param>
        /// <param name="newImg">The image with the background removed.</param>

        private void ImageWriterAssistance(string path, Mat newImg)
        {
            DirectoryInfo? dirParentParentParentInfo = new DirectoryInfo(path).Parent?.Parent?.Parent?.Parent;
            DirectoryInfo? dirParentParentInfo = new DirectoryInfo(path).Parent?.Parent?.Parent;
            DirectoryInfo? dirParentInfo = new DirectoryInfo(path).Parent?.Parent;
            DirectoryInfo? dirInfo = new DirectoryInfo(path).Parent;
            string? dirName = dirInfo?.Name!;
            string? dirParentName = dirParentInfo?.Name!;
            string? dirParentParentName = dirParentParentInfo?.Name!;
            string? dirParentParentParentName = dirParentParentParentInfo?.Name!;
            string imgName = Path.GetFileName(path);
            string specificOutputDirectory = Path.Combine(OutputDirectory, dirParentParentParentName, dirParentParentName, dirParentName, dirName);

            NewImageWrite.DirrectoryCreate(specificOutputDirectory, newImg, imgName);
        }
    }
}ØOriginalContent¿™SelectionsëÉ•Caret¿•StartÕR‡£EndÕg"®FilePathŸxD:\Project\AI_ML_DS\Minor_Project_Ai_Plant_Recognition\Minor_Project_Ai_Plant_Recognition\SorceCode\DataPreprocessing.cs®Language¢C#ëíìÅ•Value Ÿ+every code related to this error i selected¿®ResponseÖßContent⁄∑The error "Attempted to read or write protected memory" often occurs when there's an attempt to access memory that is not allocated, or it has been disposed of. This is common when dealing with unmanaged resources or interop services.

In your case, it seems like you're using Emgu.CV and Python.Runtime, both of which use unmanaged resources. The error might be due to improper handling of these resources.

Here are a few things you can try:

1. Ensure that you're not trying to access an object after it's been disposed of. For example, if you're using a `Mat` object after calling `Dispose` on it, you'll get this error.

2. If you're using multithreading, make sure that you're not accessing shared resources concurrently from multiple threads. You might need to use locks to synchronize access to shared resources.

3. If you're using Python.Runtime, make sure that you're managing the Python Global Interpreter Lock (GIL) correctly. You need to acquire the GIL before you use any Python objects, and release it when you're done.

Without seeing the exact line of code that's causing the error, it's hard to give a more specific solution. But these general tips should help you troubleshoot the issue.§Type ¶StatusØFollowUpPromptsíŸDCan you provide the exact line of code where the error is occurring?Ÿ?Is there a specific scenario or input that triggers this error?≥CodeVulnerabilitiesê∂LoggedSkillInvocations¿Ü®DateTime◊ˇö{Äf(µo™ThreadName¿∞CopilotSessionIdÇ§GuidŸ$64b71c8f-ffb9-409f-957d-1086d9b01afb®ClientIdÅ¢IdŸ4Microsoft.VisualStudio.Conversations.Chat.HelpWindowßRequestÅßRequestïŸ$75e72797-f7a5-4a1d-aac5-d19d28de1f11Ÿ$3698941e-b1ca-41ad-a482-94ce7ae2bcdeëÜØProviderMonikerÇ§NameŸ6Microsoft.VisualStudio.Copilot.DocumentContextProviderßVersion£0.1¶Member§file©CanReduce√©RequestIdŸ$75e72797-f7a5-4a1d-aac5-d19d28de1f11©Reference¿•Value»ÉádŸëMicrosoft.VisualStudio.Copilot.DocumentContext, Microsoft.VisualStudio.Copilot, Version=0.2.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3aÖßContent⁄Ç$using Emgu.CV;
using Emgu.CV.CvEnum;
using Emgu.CV.Util;
using Python.Runtime;
using System.Drawing;

namespace Minor_Project_Ai_Plant_Recognition.SorceCode.Preprocessing
{
    /// <summary>
    /// This class is responsible for parsing images from the given directory path.
    /// It writes the paths of the images to a text file.
    /// </summary>
    internal class ImageAccess
    {
        /// <summary>
        /// Parses the directories for image files and writes their paths to a text file.
        /// </summary>
        /// <param name="path">The base path of the directories.</param>
        /// <param name="pathTextFile">The path of the text file to write to.</param>
        public void DirectoryParser(string path, string pathTextFile, string action)
        {
            string[] directories;
            List<string> directoriesList = pathMakerBasedOnAction(path, action);
            directories = directoriesList.ToArray();

            Directory.CreateDirectory(pathTextFile);

            if (action == "Augment" || action == "BckgrndRemove" || action == "Normalization")
            {
                DirParserByImgDim(directories, pathTextFile);
            }
            else if (action == "Resize" || action == "parse")
            {
                DirParserByClass(directories, pathTextFile);
            }
            else
            {
                throw new ArgumentOutOfRangeException($"The action '{action}' does not exist.");
            }
        }

        public void DirParserByClass(string[] directories, string pathTextFile)
        {
            if (File.Exists(Path.Combine(pathTextFile, "dataset_base.txt")))
            {
                File.Delete(Path.Combine(pathTextFile, "dataset_base.txt"));
            }
            using (StreamWriter writer = new(Path.Combine(pathTextFile, "dataset_base.txt"), true))
            {
                foreach (string directory in directories)
                {
                    if (!Directory.Exists(directory))
                    {
                        throw new DirectoryNotFoundException($"The directory '{directory}' does not exist.");
                    }

                    foreach (string subdirectory in Directory.EnumerateDirectories(directory))
                    {
                        foreach (string filePath in Directory.EnumerateFiles(subdirectory))
                        {
                            string extension = Path.GetExtension(filePath);
                            if (extension == ".jpg" || extension == ".png")
                            {
                                writer.WriteLine(filePath);
                            }
                        }
                    }
                }
            }
        }

        public void DirParserByImgDim(string[] directories, string pathTextFile)
        {
            //using (StreamWriter writer = new(Path.Combine(pathTextFile, $"dataset_.{parentName}txt"), false))
            if (File.Exists(Path.Combine(pathTextFile, $"dataset_size224_224.txt")))
            {
                File.Delete(Path.Combine(pathTextFile, $"dataset_size224_224.txt"));
            }
            if (File.Exists(Path.Combine(pathTextFile, $"dataset_size299_299.txt")))
            {
                File.Delete(Path.Combine(pathTextFile, $"dataset_size299_299.txt"));
            }

            foreach (string directory in directories)
            {
                if (new DirectoryInfo(directory).Parent!.Name == "size224_224")
                {
                    if (!Directory.Exists(directory))
                    {
                        throw new DirectoryNotFoundException($"The directory '{directory}' does not exist.");
                    }
                    using (StreamWriter writer = new(Path.Combine(pathTextFile, $"dataset_size224_224.txt"), true))
                    {
                        foreach (string subdirectory in Directory.EnumerateDirectories(directory))
                        {
                            foreach (string filePath in Directory.EnumerateFiles(subdirectory))
                            {
                                string extension = Path.GetExtension(filePath);
                                if (extension == ".jpg" || extension == ".png")
                                {
                                    writer.WriteLine(filePath);
                                }
                            }
                        }
                    }
                }
                else if (new DirectoryInfo(directory).Parent!.Name == "size299_299")
                {
                    if (!Directory.Exists(directory))
                    {
                        throw new DirectoryNotFoundException($"The directory '{directory}' does not exist.");
                    }
                    using (StreamWriter writer = new(Path.Combine(pathTextFile, $"dataset_size299_299.txt"), true))
                    {
                        foreach (string subdirectory in Directory.EnumerateDirectories(directory))
                        {
                            foreach (string filePath in Directory.EnumerateFiles(subdirectory))
                            {
                                string extension = Path.GetExtension(filePath);
                                if (extension == ".jpg" || extension == ".png")
                                {
                                    writer.WriteLine(filePath);
                                }
                            }
                        }
                    }
                }
                else
                {
                    throw new DirectoryNotFoundException($"The directory does not exist.");
                }
            }
        }

        /// <summary>
        /// Constructs a list of directories based on the specified action.
        /// </summary>
        /// <param name="path">The base path to use when constructing the directories.</param>
        /// <param name="action">The action to base the directories on. Can be "resize", "parse", or "Augment".</param>
        /// <returns>A list of directories constructed based on the specified action.</returns>
        public List<string> pathMakerBasedOnAction(string path, string action)
        {
            List<string> directories = new List<string>();
            List<string> tempDir = new List<string>();

            if (action == "Resize" || action == "parse")
            {
                directories.Add(Path.Combine(path, "Medicinal_Leaf_dataset"));
                directories.Add(Path.Combine(path, "Medicinal_plant_dataset"));
            }
            else if (action == "Augment")
            {
                tempDir.Add(Path.Combine(path, "size224_224"));
                tempDir.Add(Path.Combine(path, "size299_299"));

                foreach (string dir in tempDir.ToList()) // Use ToList to create a copy for iteration
                {
                    directories.AddRange(pathMakerBasedOnAction(dir, "parse"));
                }
            }
            else if (action == "BckgrndRemove")
            {
                List<string> dirNames = new List<string> { "flipped", "noised", "resized", "rotated", "translated" };
                List<string> dimension = new List<string> { "size224_224", "size299_299" };
                foreach (string dirName in dirNames)
                {
                    foreach (string dim in dimension)
                    {
                        tempDir.Add(Path.Combine(path, dirName, dim));
                    }
                }

                foreach (string dir in tempDir.ToList()) // Use ToList to create a copy for iteration
                {
                    directories.AddRange(pathMakerBasedOnAction(dir, "parse"));
                }
            }
            else if (action == "Normalization")
            {
                List<string> dirNames = new List<string> { "flipped", "noised", "resized", "rotated", "translated" };
                List<string> dimension = new List<string> { "size224_224", "size299_299" };
                foreach (string dirName in dirNames)
                {
                    foreach (string dim in dimension)
                    {
                        tempDir.Add(Path.Combine(path, dirName, dim));
                    }
                }

                foreach (string dir in tempDir.ToList()) // Use ToList to create a copy for iteration
                {
                    directories.AddRange(pathMakerBasedOnAction(dir, "parse"));
                }
            }
            return directories;
        }
    }

    /// <summary>
    /// This class is responsible for writing images to a directory.
    /// </summary>
    internal class NewImageWrite
    {
        /// <summary>
        /// Creates a directory and writes an image to it.
        /// </summary>
        /// <param name="path">The path of the directory to create.</param>
        /// <param name="newImg">The image to write.</param>
        /// <param name="imgName">The name of the image file.</param>
        public static void DirrectoryCreate(string path, Mat newImg, string imgName)
        {
            if (!Directory.Exists(path))
            {
                try
                {
                    Directory.CreateDirectory(path);
                }
                catch (Exception e)
                {
                    Console.WriteLine($"Failed to create directory: {e}");
                }
            }

            WriteImage(path, newImg, imgName);
        }

        /// <summary>
        /// Writes an image to a file.
        /// </summary>
        /// <param name="path">The path of the file to write to.</param>
        /// <param name="newImg">The image to write.</param>
        /// <param name="imgName">The name of the image file.</param>
        private static void WriteImage(string path, Mat newImg, string imgName)
        {
            string newPath = Path.Combine(path, imgName);

            try
            {
                CvInvoke.Imwrite(newPath, newImg);
            }
            catch (IOException e)
            {
                Console.WriteLine("In NewImageWriter");
                Console.WriteLine($"Failed to write image: {e}");
            }
        }
    }

    /// <summary>
    /// This class is responsible for resizing images.
    /// </summary>
    internal class ImageResize
    {
        /// <summary>
        /// The directory to output the resized images to.
        /// </summary>
        public string OutputDirectory { get; } = "D:\\Project\\AI_ML_DS\\Minor_Project_Ai_Plant_Recognition\\Minor_Project_Ai_Plant_Recognition\\Data\\Dataset(resized)";

        private readonly NewImageWrite _newImageWrite = new NewImageWrite();

        /// <summary>
        /// Resizes the images specified in the text file at the given path.
        /// </summary>
        /// <param name="path">The path of the text file containing the image paths.</param>
        public void ResizeFactory(string path)
        {
            string textPath = Path.Combine(path, "dataset_base.txt");

            ResizeDirectory(textPath, 224, 224);
            ResizeDirectory(textPath, 299, 299);
        }

        public void ResizeDirectory(string path, int width, int height)
        {
            var lines = File.ReadLines(path);
            Parallel.ForEach(lines, (line) =>
            {
                Resizer(line, width, height);
            });
        }

        /// <summary>
        /// Resizes an image to the specified width and height.
        /// </summary>
        /// <param name="path">The path of the image to resize.</param>
        /// <param name="width">The width to resize to.</param>
        /// <param name="height">The height to resize to.</param>
        private void Resizer(string path, int width, int height)
        {
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);
            Mat resizedImage = new Mat();
            CvInvoke.Resize(image, resizedImage, new Size(width, height), 0, 0, Inter.Area);

            ImageWriterAssistance(path, resizedImage, width, height);
        }

        /// <summary>
        /// Assists in writing the resized image to the output directory.
        /// </summary>
        /// <param name="path">The path of the original image.</param>
        /// <param name="newImg">The resized image.</param>
        /// <param name="width">The width of the resized image.</param>
        /// <param name="height">The height of the resized image.</param>
        private void ImageWriterAssistance(string path, Mat newImg, int width, int height)
        {
            DirectoryInfo? dirParentInfo = new DirectoryInfo(path).Parent?.Parent;
            DirectoryInfo? dirInfo = new DirectoryInfo(path).Parent;
            string? dirName = dirInfo?.Name!;
            string? dirParentName = dirParentInfo?.Name!;
            string imgName = Path.GetFileName(path);
            string specificOutputDirectory = Path.Combine(OutputDirectory, $"size{width}_{height}", dirParentName, dirName);

            NewImageWrite.DirrectoryCreate(specificOutputDirectory, newImg, imgName);
        }
    }

    /// <summary>
    /// This class is responsible for Data Augmentation.
    /// </summary>
    internal class DataAugmentation
    {
        private readonly NewImageWrite _newImageWrite = new NewImageWrite();

        /// <summary>
        /// Augments the images specified in the text file at the given path.
        /// </summary>
        /// <param name="path">The path of the text file containing the image paths.</param>
        public void AugmentFactory(string path)
        {
            string path224 = Path.Combine(path, "dataset_size224_224.txt");
            string path299 = Path.Combine(path, "dataset_size299_299.txt");

            Task path224Task = Task.Run(() => AugmentDirectory(path224, "224Task"));
            Task path299Task = Task.Run(() => AugmentDirectory(path299, "299Task"));

            Task.WaitAll(path224Task, path299Task);
        }

        public void AugmentDirectory(string path, string taskName)
        {
            if (taskName == "224Task")
            {
                int totalLines = File.ReadLines(path).Count();
                {
                    using (StreamReader reader = new StreamReader(path))
                    {
                        string line;
                        while ((line = reader.ReadLine()!) != null)
                        {
                            FlipAugmenter(line);
                            RotateAugmenter(line);
                            NoiseAugmenter(line);
                            TranslateAugmenter(line);
                            CopyResizedImage(line);
                        }
                    }
                }
            }
            else if (taskName == "299Task")
            {
                int totalLines = File.ReadLines(path).Count();
                {
                    using (StreamReader reader = new StreamReader(path))
                    {
                        string line;
                        while ((line = reader.ReadLine()!) != null)
                        {
                            FlipAugmenter(line);
                            RotateAugmenter(line);
                            NoiseAugmenter(line);
                            TranslateAugmenter(line);
                            CopyResizedImage(line);
                        }
                    }
                }
            }
            else
            {
                throw new ArgumentOutOfRangeException($"The task '{taskName}' does not exist.");
            }
        }

        /// <summary>
        /// Augments an image by flipping it.
        /// </summary>
        /// <param name="path">The path of the image to augment.</param>
        private void FlipAugmenter(string path)
        {
            string action = "flipped";
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);
            Mat flippedImage = new Mat();
            CvInvoke.Flip(image, flippedImage, FlipType.Both);

            ImageWriterAssistance(path, flippedImage, action);
        }

        /// <summary>
        /// Augments an image by rotating it.
        /// </summary>
        /// <param name="path">The path of the image to augment.</param>
        private void RotateAugmenter(string path)
        {
            string action = "rotated";
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);
            Mat rotatedImage = new Mat();
            CvInvoke.Rotate(image, rotatedImage, RotateFlags.Rotate90Clockwise);

            ImageWriterAssistance(path, rotatedImage, action);
        }

        /// <summary>
        /// Augments an image by adding noise to it.
        /// </summary>
        /// <param name="path">The path of the image to augment.</param>
        private void NoiseAugmenter(string path)
        {
            string action = "noised";
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);
            Mat noisedImage = new Mat();
            CvInvoke.GaussianBlur(image, noisedImage, new Size(5, 5), 0);

            ImageWriterAssistance(path, noisedImage, action);
        }

        /// <summary>
        /// Augments an image by translating it.
        /// </summary>
        /// <param name="path">The path of the image to augment.</param>
        private void TranslateAugmenter(string path)
        {
            string action = "translated";
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);
            int imageWidth = image.Width;
            int imageHeight = image.Height;
            Mat translatedImage = new Mat();
            Matrix<float> shiftMatrix = new Matrix<float>(2, 3);
            Random rand = new Random();
            int shiftX = rand.Next(-50, 50);  // Random shift in x direction between -50 and 50
            int shiftY = rand.Next(-50, 50);  // Random shift in y direction between -50 and 50

            shiftMatrix[0, 0] = 1;  // Identity element
            shiftMatrix[1, 1] = 1;  // Identity element
            shiftMatrix[0, 2] = shiftX;  // Shift in x direction
            shiftMatrix[1, 2] = shiftY;  // Shift in y direction
            CvInvoke.WarpAffine(image, translatedImage, shiftMatrix, new Size(imageWidth, imageHeight), 0);

            ImageWriterAssistance(path, translatedImage, action);
        }

        /// <summary>
        /// Augments an image by copying it to the output directory.
        /// </summary>
        /// <param name="path"></param>
        private void CopyResizedImage(string path)
        {
            string action = "resized";
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);
            Mat copyResizedImage = image;

            ImageWriterAssistance(path, copyResizedImage, action);
        }

        /// <summary>
        /// The directory to output the augmented images to.
        /// </summary>
        public string OutputDirectory { get; } = "D:\\Project\\AI_ML_DS\\Minor_Project_Ai_Plant_Recognition\\Minor_Project_Ai_Plant_Recognition\\Data\\Dataset(augmented)";

        /// <summary>
        /// Assists in writing the augmented image to the output directory.
        /// </summary>
        /// <param name="path">The path of the original image.</param>
        /// <param name="newImg">The augmented image.</param>
        private void ImageWriterAssistance(string path, Mat newImg, string action)
        {
            DirectoryInfo? directoryParentParentInfo = new DirectoryInfo(path).Parent?.Parent?.Parent;
            DirectoryInfo? dirParentInfo = new DirectoryInfo(path).Parent?.Parent;
            DirectoryInfo? dirInfo = new DirectoryInfo(path).Parent;
            string? dirName = dirInfo?.Name!;
            string? dirParentName = dirParentInfo?.Name!;
            string? dirParentParentName = directoryParentParentInfo?.Name!;
            string imgName = Path.GetFileName(path);
            string specificOutputDirectory = Path.Combine(OutputDirectory, action, dirParentParentName, dirParentName, dirName);

            NewImageWrite.DirrectoryCreate(specificOutputDirectory, newImg, imgName);
        }
    }

    /// <summary>
    /// This class is responsible for removing the background from images.
    /// </summary>
    internal class BckgrndRemover
    {
        private readonly NewImageWrite _newImageWrite = new NewImageWrite();

        /// <summary>
        /// Removes the background from the images specified in the text file at the given path.
        /// </summary>
        /// <param name="path">The path of the text file containing the image paths.</param>
        public void RemoveBackgroundFactory(string path)
        {
            string path224 = Path.Combine(path, "dataset_size224_224.txt");
            string path299 = Path.Combine(path, "dataset_size299_299.txt");

            Task path224Task = Task.Run(() => BackGrndRemoveDirectory(path224, "224Task"));
            Task path299Task = Task.Run(() => BackGrndRemoveDirectory(path299, "299Task"));

            Task.WaitAll(path224Task, path299Task);
            //// Path to the Python DLL
            //Runtime.PythonDLL = @"C:\Users\kumar\AppData\Local\Programs\Python\Python312\python312.dll";
            //// Setting the PYTHONHOME environment variable
            //Environment.SetEnvironmentVariable("PYTHONHOME", @"C:\Users\kumar\AppData\Local\Programs\Python\Python312", EnvironmentVariableTarget.Process);

            //try
            //{
            //    // Initialize the Python Engine
            //    PythonEngine.Initialize();

            //    int totalLines = File.ReadLines(Path.Combine(path, "dataset.txt")).Count();
            //    using (var pbar = new ProgressBar(totalLines, "Removing Background", new ProgressBarOptions { ProgressCharacter = '#' }))
            //    {
            //        using (StreamReader reader = new StreamReader(Path.Combine(path, "dataset.txt")))
            //        {
            //            string line;
            //            while ((line = reader.ReadLine()!) != null)
            //            {
            //                PythonScriptRemoveBackground(line);
            //                pbar.Tick();
            //            }
            //        }
            //    }
            //}
            //catch (Exception e)
            //{
            //    Console.WriteLine($"Failed to remove background: {e.Message}");
            //}
            //finally
            //{
            //    // Shutdown the Python Engine
            //    PythonEngine.Shutdown();
            //}
        }

        private void BackGrndRemoveDirectory(string path, string taskName)
        {
            // Path to the Python DLL
            Runtime.PythonDLL = @"C:\Users\kumar\AppData\Local\Programs\Python\Python312\python312.dll";
            // Setting the PYTHONHOME environment variable
            Environment.SetEnvironmentVariable("PYTHONHOME", @"C:\Users\kumar\AppData\Local\Programs\Python\Python312", EnvironmentVariableTarget.Process);

            try
            {
                PythonEngine.Initialize();

                if (taskName == "224Task")
                {
                    int totalLines = File.ReadLines(path).Count();
                    {
                        using (StreamReader reader = new StreamReader(path))
                        {
                            string line;
                            while ((line = reader.ReadLine()!) != null)
                            {
                                PythonScriptRemoveBackground(line);
                            }
                        }
                    }
                }
                else if (taskName == "299Task")
                {
                    int totalLines = File.ReadLines(path).Count();
                    {
                        using (StreamReader reader = new StreamReader(path))
                        {
                            string line;
                            while ((line = reader.ReadLine()!) != null)
                            {
                                PythonScriptRemoveBackground(line);
                            }
                        }
                    }
                }
                else
                {
                    throw new ArgumentOutOfRangeException($"The task '{taskName}' does not exist.");
                }
            }
            catch (Exception e)
            {
                Console.WriteLine($"Failed to remove background: {e.Message}");
            }
            finally
            {
                // Shutdown the Python Engine
                PythonEngine.Shutdown();
            }
        }

        /// <summary>
        /// Executes a Python script to remove the background from an image.
        /// </summary>
        /// <param name="path">The path of the image to process.</param>
        private void PythonScriptRemoveBackground(string path)
        {
            using (Py.GIL())
            {
                // Get the output path for the processed image
                string outputPath = ImageWriterAssistance(path);

                // Read the Python script
                string pythonScript = System.IO.File.ReadAllText(@"D:\Project\AI_ML_DS\Minor_Project_Ai_Plant_Recognition\Minor_Project_Ai_Plant_Recognition\SorceCode\remove_background.py");
                // Run the Python script
                PythonEngine.RunSimpleString(pythonScript);
                // Call the remove_backgrnd function from the Python script
                dynamic removeBackground = PythonEngine.RunSimpleString($"remove_backgrnd(r'{path}', r'{outputPath}')");
            }
        }

        /// <summary>
        /// The directory to output the images with the background removed to.
        /// </summary>
        public string OutputDirectory { get; } = "D:\\Project\\AI_ML_DS\\Minor_Project_Ai_Plant_Recognition\\Minor_Project_Ai_Plant_Recognition\\Data\\Dataset(background_removed)";

        /// <summary>
        /// Assists in writing the image with the background removed to the output directory.
        /// </summary>
        /// <param name="path">The path of the original image.</param>
        /// <param name="newImg">The image with the background removed.</param>
        private string ImageWriterAssistance(string path)
        {
            DirectoryInfo? dirParentParentParentInfo = new DirectoryInfo(path).Parent?.Parent?.Parent?.Parent;
            DirectoryInfo? dirParentParentInfo = new DirectoryInfo(path).Parent?.Parent?.Parent;
            DirectoryInfo? dirParentInfo = new DirectoryInfo(path).Parent?.Parent;
            DirectoryInfo? dirInfo = new DirectoryInfo(path).Parent;
            string? dirName = dirInfo?.Name!;
            string? dirParentName = dirParentInfo?.Name!;
            string? dirParentParentName = dirParentParentInfo?.Name!;
            string? dirParentParentParentName = dirParentParentParentInfo?.Name!;
            string imgName = Path.GetFileName(path);
            string specificOutputDirectory = Path.Combine(OutputDirectory, dirParentParentParentName, dirParentParentName, dirParentName, dirName);

            return Path.Combine(specificOutputDirectory, imgName);
            // Regular image write is not needed.
            //_newImageWrite.DirrectoryCreate(specificOutputDirectory, newImg, imgName);
        }
    }

    /// <summary>
    /// This class is responsble for normalization of images data.
    /// </summary>
    internal class Normalization
    {
        private readonly NewImageWrite _newImageWrite = new NewImageWrite();

        /// <summary>
        /// Normalizes the images specified in the text file at the given path.
        /// </summary>
        /// <param name="path">The path of the text file containing the image paths.</param>
        public void NormalizationFactor(string path)
        {
            string path224 = Path.Combine(path, "dataset_size224_224.txt");
            string path299 = Path.Combine(path, "dataset_size299_299.txt");

            Task path224Task = Task.Run(() => NormalizeDirectory(path224, "224Task"));
            Task path299Task = Task.Run(() => NormalizeDirectory(path299, "299Task"));

            Task.WaitAll(path224Task, path299Task);
            //int totalLines = File.ReadLines(Path.Combine(path, "dataset.txt")).Count();

            //using (var pbar = new ProgressBar(totalLines, "Resizing", new ProgressBarOptions { ProgressCharacter = '#' }))
            //{
            //    using (StreamReader reader = new StreamReader(Path.Combine(path, "dataset.txt")))
            //    {
            //        string line;
            //        while ((line = reader.ReadLine()!) != null)
            //        {
            //            NormalizeColorWise(line);
            //            pbar.Tick();
            //        }
            //    }
            //}
        }

        private void NormalizeDirectory(string path, string taskName)
        {
            if (taskName == "224Task")
            {
                int totalLines = File.ReadLines(path).Count();
                {
                    using (StreamReader reader = new StreamReader(path))
                    {
                        string line;
                        while ((line = reader.ReadLine()!) != null)
                        {
                            NormalizeColorWise(line);
                        }
                    }
                }
            }
            else if (taskName == "299Task")
            {
                int totalLines = File.ReadLines(path).Count();
                {
                    using (StreamReader reader = new StreamReader(path))
                    {
                        string line;
                        while ((line = reader.ReadLine()!) != null)
                        {
                            NormalizeColorWise(line);
                        }
                    }
                }
            }
            else
            {
                throw new ArgumentOutOfRangeException($"The task '{taskName}' does not exist.");
            }
        }

        /// <summary>
        /// Normalizes an image using min-max.
        /// </summary>
        /// <param name="path">The path of the image to process.</param>
        public void NormalizeColorWise(string path)
        {
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);

            Mat normalizedImage = image.Clone();
            VectorOfMat vm = new VectorOfMat();
            CvInvoke.Split(image, vm);

            for (int i = 0; i < vm.Size; i++)
            {
                Mat channel = vm[i];
                CvInvoke.Normalize(channel, channel, 0, 255, NormType.MinMax);
            }
            CvInvoke.Merge(vm, normalizedImage);

            ImageWriterAssistance(path, normalizedImage);
        }

        /// <summary>
        /// The directory to output the normalized images to the directory.
        /// </summary>
        public string OutputDirectory { get; } = "D:\\Project\\AI_ML_DS\\Minor_Project_Ai_Plant_Recognition\\Minor_Project_Ai_Plant_Recognition\\Data\\Dataset(normalized)";

        /// <summary>
        /// Assists in writing the normalized image to the output directory.
        /// </summary>
        /// <param name="path">The path of the original image.</param>
        /// <param name="newImg">The image with the background removed.</param>

        private void ImageWriterAssistance(string path, Mat newImg)
        {
            DirectoryInfo? dirParentParentParentInfo = new DirectoryInfo(path).Parent?.Parent?.Parent?.Parent;
            DirectoryInfo? dirParentParentInfo = new DirectoryInfo(path).Parent?.Parent?.Parent;
            DirectoryInfo? dirParentInfo = new DirectoryInfo(path).Parent?.Parent;
            DirectoryInfo? dirInfo = new DirectoryInfo(path).Parent;
            string? dirName = dirInfo?.Name!;
            string? dirParentName = dirParentInfo?.Name!;
            string? dirParentParentName = dirParentParentInfo?.Name!;
            string? dirParentParentParentName = dirParentParentParentInfo?.Name!;
            string imgName = Path.GetFileName(path);
            string specificOutputDirectory = Path.Combine(OutputDirectory, dirParentParentParentName, dirParentParentName, dirParentName, dirName);

            NewImageWrite.DirrectoryCreate(specificOutputDirectory, newImg, imgName);
        }
    }
}ØOriginalContent¿™SelectionsëÉ•Caret¿•StartÕR‡£EndÕg"®FilePathŸxD:\Project\AI_ML_DS\Minor_Project_Ai_Plant_Recognition\Minor_Project_Ai_Plant_Recognition\SorceCode\DataPreprocessing.cs®Language¢C#ëíìÅ•Value Ÿ)at line 552 of selected code causing this¿®ResponseÖßContent⁄TThe line of code you're referring to is:

```csharp
PythonEngine.RunSimpleString(pythonScript);
```

This line is executing a Python script in the context of the Python engine. The "Attempted to read or write protected memory" error could be due to a few reasons:

1. **Multithreading**: If you're running this code in multiple threads, you need to ensure that each thread has its own Python environment. Python's Global Interpreter Lock (GIL) allows only one thread to execute Python code at a time. You can use `PythonEngine.BeginAllowThreads` and `PythonEngine.EndAllowThreads` to manage the GIL.

2. **Python script error**: There might be an error in your Python script that's causing this issue. Make sure your Python script is correct and can run without errors in a standalone Python environment.

3. **Memory management**: The Python engine might be trying to access memory that has been deallocated. Make sure you're not disposing of any objects that are still in use by the Python engine.

4. **Python engine initialization**: The Python engine should be initialized only once. If you're initializing it multiple times, it might cause issues.

Without more information about your Python script and how you're using the Python engine, it's hard to give a more specific solution. But these are some general tips that might help you troubleshoot the issue.§Type ¶StatusØFollowUpPromptsíŸAHow can I ensure that each thread has its own Python environment?ŸmCan you provide an example of how to use `PythonEngine.BeginAllowThreads` and `PythonEngine.EndAllowThreads`?≥CodeVulnerabilitiesê∂LoggedSkillInvocations¿Ü®DateTime◊ˇd≈=¿f(µ™™ThreadName¿∞CopilotSessionIdÇ§GuidŸ$64b71c8f-ffb9-409f-957d-1086d9b01afb®ClientIdÅ¢IdŸ4Microsoft.VisualStudio.Conversations.Chat.HelpWindowßRequestÅßRequestïŸ$6542bc7d-a1a0-4971-bd6b-384922cbf383Ÿ$75024ccc-f028-4422-a4ea-21dec0118c2aëÜØProviderMonikerÇ§NameŸ6Microsoft.VisualStudio.Copilot.DocumentContextProviderßVersion£0.1¶Member§file©CanReduce√©RequestIdŸ$6542bc7d-a1a0-4971-bd6b-384922cbf383©Reference¿•Value»ÉádŸëMicrosoft.VisualStudio.Copilot.DocumentContext, Microsoft.VisualStudio.Copilot, Version=0.2.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3aÖßContent⁄Ç$using Emgu.CV;
using Emgu.CV.CvEnum;
using Emgu.CV.Util;
using Python.Runtime;
using System.Drawing;

namespace Minor_Project_Ai_Plant_Recognition.SorceCode.Preprocessing
{
    /// <summary>
    /// This class is responsible for parsing images from the given directory path.
    /// It writes the paths of the images to a text file.
    /// </summary>
    internal class ImageAccess
    {
        /// <summary>
        /// Parses the directories for image files and writes their paths to a text file.
        /// </summary>
        /// <param name="path">The base path of the directories.</param>
        /// <param name="pathTextFile">The path of the text file to write to.</param>
        public void DirectoryParser(string path, string pathTextFile, string action)
        {
            string[] directories;
            List<string> directoriesList = pathMakerBasedOnAction(path, action);
            directories = directoriesList.ToArray();

            Directory.CreateDirectory(pathTextFile);

            if (action == "Augment" || action == "BckgrndRemove" || action == "Normalization")
            {
                DirParserByImgDim(directories, pathTextFile);
            }
            else if (action == "Resize" || action == "parse")
            {
                DirParserByClass(directories, pathTextFile);
            }
            else
            {
                throw new ArgumentOutOfRangeException($"The action '{action}' does not exist.");
            }
        }

        public void DirParserByClass(string[] directories, string pathTextFile)
        {
            if (File.Exists(Path.Combine(pathTextFile, "dataset_base.txt")))
            {
                File.Delete(Path.Combine(pathTextFile, "dataset_base.txt"));
            }
            using (StreamWriter writer = new(Path.Combine(pathTextFile, "dataset_base.txt"), true))
            {
                foreach (string directory in directories)
                {
                    if (!Directory.Exists(directory))
                    {
                        throw new DirectoryNotFoundException($"The directory '{directory}' does not exist.");
                    }

                    foreach (string subdirectory in Directory.EnumerateDirectories(directory))
                    {
                        foreach (string filePath in Directory.EnumerateFiles(subdirectory))
                        {
                            string extension = Path.GetExtension(filePath);
                            if (extension == ".jpg" || extension == ".png")
                            {
                                writer.WriteLine(filePath);
                            }
                        }
                    }
                }
            }
        }

        public void DirParserByImgDim(string[] directories, string pathTextFile)
        {
            //using (StreamWriter writer = new(Path.Combine(pathTextFile, $"dataset_.{parentName}txt"), false))
            if (File.Exists(Path.Combine(pathTextFile, $"dataset_size224_224.txt")))
            {
                File.Delete(Path.Combine(pathTextFile, $"dataset_size224_224.txt"));
            }
            if (File.Exists(Path.Combine(pathTextFile, $"dataset_size299_299.txt")))
            {
                File.Delete(Path.Combine(pathTextFile, $"dataset_size299_299.txt"));
            }

            foreach (string directory in directories)
            {
                if (new DirectoryInfo(directory).Parent!.Name == "size224_224")
                {
                    if (!Directory.Exists(directory))
                    {
                        throw new DirectoryNotFoundException($"The directory '{directory}' does not exist.");
                    }
                    using (StreamWriter writer = new(Path.Combine(pathTextFile, $"dataset_size224_224.txt"), true))
                    {
                        foreach (string subdirectory in Directory.EnumerateDirectories(directory))
                        {
                            foreach (string filePath in Directory.EnumerateFiles(subdirectory))
                            {
                                string extension = Path.GetExtension(filePath);
                                if (extension == ".jpg" || extension == ".png")
                                {
                                    writer.WriteLine(filePath);
                                }
                            }
                        }
                    }
                }
                else if (new DirectoryInfo(directory).Parent!.Name == "size299_299")
                {
                    if (!Directory.Exists(directory))
                    {
                        throw new DirectoryNotFoundException($"The directory '{directory}' does not exist.");
                    }
                    using (StreamWriter writer = new(Path.Combine(pathTextFile, $"dataset_size299_299.txt"), true))
                    {
                        foreach (string subdirectory in Directory.EnumerateDirectories(directory))
                        {
                            foreach (string filePath in Directory.EnumerateFiles(subdirectory))
                            {
                                string extension = Path.GetExtension(filePath);
                                if (extension == ".jpg" || extension == ".png")
                                {
                                    writer.WriteLine(filePath);
                                }
                            }
                        }
                    }
                }
                else
                {
                    throw new DirectoryNotFoundException($"The directory does not exist.");
                }
            }
        }

        /// <summary>
        /// Constructs a list of directories based on the specified action.
        /// </summary>
        /// <param name="path">The base path to use when constructing the directories.</param>
        /// <param name="action">The action to base the directories on. Can be "resize", "parse", or "Augment".</param>
        /// <returns>A list of directories constructed based on the specified action.</returns>
        public List<string> pathMakerBasedOnAction(string path, string action)
        {
            List<string> directories = new List<string>();
            List<string> tempDir = new List<string>();

            if (action == "Resize" || action == "parse")
            {
                directories.Add(Path.Combine(path, "Medicinal_Leaf_dataset"));
                directories.Add(Path.Combine(path, "Medicinal_plant_dataset"));
            }
            else if (action == "Augment")
            {
                tempDir.Add(Path.Combine(path, "size224_224"));
                tempDir.Add(Path.Combine(path, "size299_299"));

                foreach (string dir in tempDir.ToList()) // Use ToList to create a copy for iteration
                {
                    directories.AddRange(pathMakerBasedOnAction(dir, "parse"));
                }
            }
            else if (action == "BckgrndRemove")
            {
                List<string> dirNames = new List<string> { "flipped", "noised", "resized", "rotated", "translated" };
                List<string> dimension = new List<string> { "size224_224", "size299_299" };
                foreach (string dirName in dirNames)
                {
                    foreach (string dim in dimension)
                    {
                        tempDir.Add(Path.Combine(path, dirName, dim));
                    }
                }

                foreach (string dir in tempDir.ToList()) // Use ToList to create a copy for iteration
                {
                    directories.AddRange(pathMakerBasedOnAction(dir, "parse"));
                }
            }
            else if (action == "Normalization")
            {
                List<string> dirNames = new List<string> { "flipped", "noised", "resized", "rotated", "translated" };
                List<string> dimension = new List<string> { "size224_224", "size299_299" };
                foreach (string dirName in dirNames)
                {
                    foreach (string dim in dimension)
                    {
                        tempDir.Add(Path.Combine(path, dirName, dim));
                    }
                }

                foreach (string dir in tempDir.ToList()) // Use ToList to create a copy for iteration
                {
                    directories.AddRange(pathMakerBasedOnAction(dir, "parse"));
                }
            }
            return directories;
        }
    }

    /// <summary>
    /// This class is responsible for writing images to a directory.
    /// </summary>
    internal class NewImageWrite
    {
        /// <summary>
        /// Creates a directory and writes an image to it.
        /// </summary>
        /// <param name="path">The path of the directory to create.</param>
        /// <param name="newImg">The image to write.</param>
        /// <param name="imgName">The name of the image file.</param>
        public static void DirrectoryCreate(string path, Mat newImg, string imgName)
        {
            if (!Directory.Exists(path))
            {
                try
                {
                    Directory.CreateDirectory(path);
                }
                catch (Exception e)
                {
                    Console.WriteLine($"Failed to create directory: {e}");
                }
            }

            WriteImage(path, newImg, imgName);
        }

        /// <summary>
        /// Writes an image to a file.
        /// </summary>
        /// <param name="path">The path of the file to write to.</param>
        /// <param name="newImg">The image to write.</param>
        /// <param name="imgName">The name of the image file.</param>
        private static void WriteImage(string path, Mat newImg, string imgName)
        {
            string newPath = Path.Combine(path, imgName);

            try
            {
                CvInvoke.Imwrite(newPath, newImg);
            }
            catch (IOException e)
            {
                Console.WriteLine("In NewImageWriter");
                Console.WriteLine($"Failed to write image: {e}");
            }
        }
    }

    /// <summary>
    /// This class is responsible for resizing images.
    /// </summary>
    internal class ImageResize
    {
        /// <summary>
        /// The directory to output the resized images to.
        /// </summary>
        public string OutputDirectory { get; } = "D:\\Project\\AI_ML_DS\\Minor_Project_Ai_Plant_Recognition\\Minor_Project_Ai_Plant_Recognition\\Data\\Dataset(resized)";

        private readonly NewImageWrite _newImageWrite = new NewImageWrite();

        /// <summary>
        /// Resizes the images specified in the text file at the given path.
        /// </summary>
        /// <param name="path">The path of the text file containing the image paths.</param>
        public void ResizeFactory(string path)
        {
            string textPath = Path.Combine(path, "dataset_base.txt");

            ResizeDirectory(textPath, 224, 224);
            ResizeDirectory(textPath, 299, 299);
        }

        public void ResizeDirectory(string path, int width, int height)
        {
            var lines = File.ReadLines(path);
            Parallel.ForEach(lines, (line) =>
            {
                Resizer(line, width, height);
            });
        }

        /// <summary>
        /// Resizes an image to the specified width and height.
        /// </summary>
        /// <param name="path">The path of the image to resize.</param>
        /// <param name="width">The width to resize to.</param>
        /// <param name="height">The height to resize to.</param>
        private void Resizer(string path, int width, int height)
        {
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);
            Mat resizedImage = new Mat();
            CvInvoke.Resize(image, resizedImage, new Size(width, height), 0, 0, Inter.Area);

            ImageWriterAssistance(path, resizedImage, width, height);
        }

        /// <summary>
        /// Assists in writing the resized image to the output directory.
        /// </summary>
        /// <param name="path">The path of the original image.</param>
        /// <param name="newImg">The resized image.</param>
        /// <param name="width">The width of the resized image.</param>
        /// <param name="height">The height of the resized image.</param>
        private void ImageWriterAssistance(string path, Mat newImg, int width, int height)
        {
            DirectoryInfo? dirParentInfo = new DirectoryInfo(path).Parent?.Parent;
            DirectoryInfo? dirInfo = new DirectoryInfo(path).Parent;
            string? dirName = dirInfo?.Name!;
            string? dirParentName = dirParentInfo?.Name!;
            string imgName = Path.GetFileName(path);
            string specificOutputDirectory = Path.Combine(OutputDirectory, $"size{width}_{height}", dirParentName, dirName);

            NewImageWrite.DirrectoryCreate(specificOutputDirectory, newImg, imgName);
        }
    }

    /// <summary>
    /// This class is responsible for Data Augmentation.
    /// </summary>
    internal class DataAugmentation
    {
        private readonly NewImageWrite _newImageWrite = new NewImageWrite();

        /// <summary>
        /// Augments the images specified in the text file at the given path.
        /// </summary>
        /// <param name="path">The path of the text file containing the image paths.</param>
        public void AugmentFactory(string path)
        {
            string path224 = Path.Combine(path, "dataset_size224_224.txt");
            string path299 = Path.Combine(path, "dataset_size299_299.txt");

            Task path224Task = Task.Run(() => AugmentDirectory(path224, "224Task"));
            Task path299Task = Task.Run(() => AugmentDirectory(path299, "299Task"));

            Task.WaitAll(path224Task, path299Task);
        }

        public void AugmentDirectory(string path, string taskName)
        {
            if (taskName == "224Task")
            {
                int totalLines = File.ReadLines(path).Count();
                {
                    using (StreamReader reader = new StreamReader(path))
                    {
                        string line;
                        while ((line = reader.ReadLine()!) != null)
                        {
                            FlipAugmenter(line);
                            RotateAugmenter(line);
                            NoiseAugmenter(line);
                            TranslateAugmenter(line);
                            CopyResizedImage(line);
                        }
                    }
                }
            }
            else if (taskName == "299Task")
            {
                int totalLines = File.ReadLines(path).Count();
                {
                    using (StreamReader reader = new StreamReader(path))
                    {
                        string line;
                        while ((line = reader.ReadLine()!) != null)
                        {
                            FlipAugmenter(line);
                            RotateAugmenter(line);
                            NoiseAugmenter(line);
                            TranslateAugmenter(line);
                            CopyResizedImage(line);
                        }
                    }
                }
            }
            else
            {
                throw new ArgumentOutOfRangeException($"The task '{taskName}' does not exist.");
            }
        }

        /// <summary>
        /// Augments an image by flipping it.
        /// </summary>
        /// <param name="path">The path of the image to augment.</param>
        private void FlipAugmenter(string path)
        {
            string action = "flipped";
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);
            Mat flippedImage = new Mat();
            CvInvoke.Flip(image, flippedImage, FlipType.Both);

            ImageWriterAssistance(path, flippedImage, action);
        }

        /// <summary>
        /// Augments an image by rotating it.
        /// </summary>
        /// <param name="path">The path of the image to augment.</param>
        private void RotateAugmenter(string path)
        {
            string action = "rotated";
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);
            Mat rotatedImage = new Mat();
            CvInvoke.Rotate(image, rotatedImage, RotateFlags.Rotate90Clockwise);

            ImageWriterAssistance(path, rotatedImage, action);
        }

        /// <summary>
        /// Augments an image by adding noise to it.
        /// </summary>
        /// <param name="path">The path of the image to augment.</param>
        private void NoiseAugmenter(string path)
        {
            string action = "noised";
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);
            Mat noisedImage = new Mat();
            CvInvoke.GaussianBlur(image, noisedImage, new Size(5, 5), 0);

            ImageWriterAssistance(path, noisedImage, action);
        }

        /// <summary>
        /// Augments an image by translating it.
        /// </summary>
        /// <param name="path">The path of the image to augment.</param>
        private void TranslateAugmenter(string path)
        {
            string action = "translated";
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);
            int imageWidth = image.Width;
            int imageHeight = image.Height;
            Mat translatedImage = new Mat();
            Matrix<float> shiftMatrix = new Matrix<float>(2, 3);
            Random rand = new Random();
            int shiftX = rand.Next(-50, 50);  // Random shift in x direction between -50 and 50
            int shiftY = rand.Next(-50, 50);  // Random shift in y direction between -50 and 50

            shiftMatrix[0, 0] = 1;  // Identity element
            shiftMatrix[1, 1] = 1;  // Identity element
            shiftMatrix[0, 2] = shiftX;  // Shift in x direction
            shiftMatrix[1, 2] = shiftY;  // Shift in y direction
            CvInvoke.WarpAffine(image, translatedImage, shiftMatrix, new Size(imageWidth, imageHeight), 0);

            ImageWriterAssistance(path, translatedImage, action);
        }

        /// <summary>
        /// Augments an image by copying it to the output directory.
        /// </summary>
        /// <param name="path"></param>
        private void CopyResizedImage(string path)
        {
            string action = "resized";
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);
            Mat copyResizedImage = image;

            ImageWriterAssistance(path, copyResizedImage, action);
        }

        /// <summary>
        /// The directory to output the augmented images to.
        /// </summary>
        public string OutputDirectory { get; } = "D:\\Project\\AI_ML_DS\\Minor_Project_Ai_Plant_Recognition\\Minor_Project_Ai_Plant_Recognition\\Data\\Dataset(augmented)";

        /// <summary>
        /// Assists in writing the augmented image to the output directory.
        /// </summary>
        /// <param name="path">The path of the original image.</param>
        /// <param name="newImg">The augmented image.</param>
        private void ImageWriterAssistance(string path, Mat newImg, string action)
        {
            DirectoryInfo? directoryParentParentInfo = new DirectoryInfo(path).Parent?.Parent?.Parent;
            DirectoryInfo? dirParentInfo = new DirectoryInfo(path).Parent?.Parent;
            DirectoryInfo? dirInfo = new DirectoryInfo(path).Parent;
            string? dirName = dirInfo?.Name!;
            string? dirParentName = dirParentInfo?.Name!;
            string? dirParentParentName = directoryParentParentInfo?.Name!;
            string imgName = Path.GetFileName(path);
            string specificOutputDirectory = Path.Combine(OutputDirectory, action, dirParentParentName, dirParentName, dirName);

            NewImageWrite.DirrectoryCreate(specificOutputDirectory, newImg, imgName);
        }
    }

    /// <summary>
    /// This class is responsible for removing the background from images.
    /// </summary>
    internal class BckgrndRemover
    {
        private readonly NewImageWrite _newImageWrite = new NewImageWrite();

        /// <summary>
        /// Removes the background from the images specified in the text file at the given path.
        /// </summary>
        /// <param name="path">The path of the text file containing the image paths.</param>
        public void RemoveBackgroundFactory(string path)
        {
            string path224 = Path.Combine(path, "dataset_size224_224.txt");
            string path299 = Path.Combine(path, "dataset_size299_299.txt");

            Task path224Task = Task.Run(() => BackGrndRemoveDirectory(path224, "224Task"));
            Task path299Task = Task.Run(() => BackGrndRemoveDirectory(path299, "299Task"));

            Task.WaitAll(path224Task, path299Task);
            //// Path to the Python DLL
            //Runtime.PythonDLL = @"C:\Users\kumar\AppData\Local\Programs\Python\Python312\python312.dll";
            //// Setting the PYTHONHOME environment variable
            //Environment.SetEnvironmentVariable("PYTHONHOME", @"C:\Users\kumar\AppData\Local\Programs\Python\Python312", EnvironmentVariableTarget.Process);

            //try
            //{
            //    // Initialize the Python Engine
            //    PythonEngine.Initialize();

            //    int totalLines = File.ReadLines(Path.Combine(path, "dataset.txt")).Count();
            //    using (var pbar = new ProgressBar(totalLines, "Removing Background", new ProgressBarOptions { ProgressCharacter = '#' }))
            //    {
            //        using (StreamReader reader = new StreamReader(Path.Combine(path, "dataset.txt")))
            //        {
            //            string line;
            //            while ((line = reader.ReadLine()!) != null)
            //            {
            //                PythonScriptRemoveBackground(line);
            //                pbar.Tick();
            //            }
            //        }
            //    }
            //}
            //catch (Exception e)
            //{
            //    Console.WriteLine($"Failed to remove background: {e.Message}");
            //}
            //finally
            //{
            //    // Shutdown the Python Engine
            //    PythonEngine.Shutdown();
            //}
        }

        private void BackGrndRemoveDirectory(string path, string taskName)
        {
            // Path to the Python DLL
            Runtime.PythonDLL = @"C:\Users\kumar\AppData\Local\Programs\Python\Python312\python312.dll";
            // Setting the PYTHONHOME environment variable
            Environment.SetEnvironmentVariable("PYTHONHOME", @"C:\Users\kumar\AppData\Local\Programs\Python\Python312", EnvironmentVariableTarget.Process);

            try
            {
                PythonEngine.Initialize();

                if (taskName == "224Task")
                {
                    int totalLines = File.ReadLines(path).Count();
                    {
                        using (StreamReader reader = new StreamReader(path))
                        {
                            string line;
                            while ((line = reader.ReadLine()!) != null)
                            {
                                PythonScriptRemoveBackground(line);
                            }
                        }
                    }
                }
                else if (taskName == "299Task")
                {
                    int totalLines = File.ReadLines(path).Count();
                    {
                        using (StreamReader reader = new StreamReader(path))
                        {
                            string line;
                            while ((line = reader.ReadLine()!) != null)
                            {
                                PythonScriptRemoveBackground(line);
                            }
                        }
                    }
                }
                else
                {
                    throw new ArgumentOutOfRangeException($"The task '{taskName}' does not exist.");
                }
            }
            catch (Exception e)
            {
                Console.WriteLine($"Failed to remove background: {e.Message}");
            }
            finally
            {
                // Shutdown the Python Engine
                PythonEngine.Shutdown();
            }
        }

        /// <summary>
        /// Executes a Python script to remove the background from an image.
        /// </summary>
        /// <param name="path">The path of the image to process.</param>
        private void PythonScriptRemoveBackground(string path)
        {
            using (Py.GIL())
            {
                // Get the output path for the processed image
                string outputPath = ImageWriterAssistance(path);

                // Read the Python script
                string pythonScript = System.IO.File.ReadAllText(@"D:\Project\AI_ML_DS\Minor_Project_Ai_Plant_Recognition\Minor_Project_Ai_Plant_Recognition\SorceCode\remove_background.py");
                // Run the Python script
                PythonEngine.RunSimpleString(pythonScript);
                // Call the remove_backgrnd function from the Python script
                dynamic removeBackground = PythonEngine.RunSimpleString($"remove_backgrnd(r'{path}', r'{outputPath}')");
            }
        }

        /// <summary>
        /// The directory to output the images with the background removed to.
        /// </summary>
        public string OutputDirectory { get; } = "D:\\Project\\AI_ML_DS\\Minor_Project_Ai_Plant_Recognition\\Minor_Project_Ai_Plant_Recognition\\Data\\Dataset(background_removed)";

        /// <summary>
        /// Assists in writing the image with the background removed to the output directory.
        /// </summary>
        /// <param name="path">The path of the original image.</param>
        /// <param name="newImg">The image with the background removed.</param>
        private string ImageWriterAssistance(string path)
        {
            DirectoryInfo? dirParentParentParentInfo = new DirectoryInfo(path).Parent?.Parent?.Parent?.Parent;
            DirectoryInfo? dirParentParentInfo = new DirectoryInfo(path).Parent?.Parent?.Parent;
            DirectoryInfo? dirParentInfo = new DirectoryInfo(path).Parent?.Parent;
            DirectoryInfo? dirInfo = new DirectoryInfo(path).Parent;
            string? dirName = dirInfo?.Name!;
            string? dirParentName = dirParentInfo?.Name!;
            string? dirParentParentName = dirParentParentInfo?.Name!;
            string? dirParentParentParentName = dirParentParentParentInfo?.Name!;
            string imgName = Path.GetFileName(path);
            string specificOutputDirectory = Path.Combine(OutputDirectory, dirParentParentParentName, dirParentParentName, dirParentName, dirName);

            return Path.Combine(specificOutputDirectory, imgName);
            // Regular image write is not needed.
            //_newImageWrite.DirrectoryCreate(specificOutputDirectory, newImg, imgName);
        }
    }

    /// <summary>
    /// This class is responsble for normalization of images data.
    /// </summary>
    internal class Normalization
    {
        private readonly NewImageWrite _newImageWrite = new NewImageWrite();

        /// <summary>
        /// Normalizes the images specified in the text file at the given path.
        /// </summary>
        /// <param name="path">The path of the text file containing the image paths.</param>
        public void NormalizationFactor(string path)
        {
            string path224 = Path.Combine(path, "dataset_size224_224.txt");
            string path299 = Path.Combine(path, "dataset_size299_299.txt");

            Task path224Task = Task.Run(() => NormalizeDirectory(path224, "224Task"));
            Task path299Task = Task.Run(() => NormalizeDirectory(path299, "299Task"));

            Task.WaitAll(path224Task, path299Task);
            //int totalLines = File.ReadLines(Path.Combine(path, "dataset.txt")).Count();

            //using (var pbar = new ProgressBar(totalLines, "Resizing", new ProgressBarOptions { ProgressCharacter = '#' }))
            //{
            //    using (StreamReader reader = new StreamReader(Path.Combine(path, "dataset.txt")))
            //    {
            //        string line;
            //        while ((line = reader.ReadLine()!) != null)
            //        {
            //            NormalizeColorWise(line);
            //            pbar.Tick();
            //        }
            //    }
            //}
        }

        private void NormalizeDirectory(string path, string taskName)
        {
            if (taskName == "224Task")
            {
                int totalLines = File.ReadLines(path).Count();
                {
                    using (StreamReader reader = new StreamReader(path))
                    {
                        string line;
                        while ((line = reader.ReadLine()!) != null)
                        {
                            NormalizeColorWise(line);
                        }
                    }
                }
            }
            else if (taskName == "299Task")
            {
                int totalLines = File.ReadLines(path).Count();
                {
                    using (StreamReader reader = new StreamReader(path))
                    {
                        string line;
                        while ((line = reader.ReadLine()!) != null)
                        {
                            NormalizeColorWise(line);
                        }
                    }
                }
            }
            else
            {
                throw new ArgumentOutOfRangeException($"The task '{taskName}' does not exist.");
            }
        }

        /// <summary>
        /// Normalizes an image using min-max.
        /// </summary>
        /// <param name="path">The path of the image to process.</param>
        public void NormalizeColorWise(string path)
        {
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);

            Mat normalizedImage = image.Clone();
            VectorOfMat vm = new VectorOfMat();
            CvInvoke.Split(image, vm);

            for (int i = 0; i < vm.Size; i++)
            {
                Mat channel = vm[i];
                CvInvoke.Normalize(channel, channel, 0, 255, NormType.MinMax);
            }
            CvInvoke.Merge(vm, normalizedImage);

            ImageWriterAssistance(path, normalizedImage);
        }

        /// <summary>
        /// The directory to output the normalized images to the directory.
        /// </summary>
        public string OutputDirectory { get; } = "D:\\Project\\AI_ML_DS\\Minor_Project_Ai_Plant_Recognition\\Minor_Project_Ai_Plant_Recognition\\Data\\Dataset(normalized)";

        /// <summary>
        /// Assists in writing the normalized image to the output directory.
        /// </summary>
        /// <param name="path">The path of the original image.</param>
        /// <param name="newImg">The image with the background removed.</param>

        private void ImageWriterAssistance(string path, Mat newImg)
        {
            DirectoryInfo? dirParentParentParentInfo = new DirectoryInfo(path).Parent?.Parent?.Parent?.Parent;
            DirectoryInfo? dirParentParentInfo = new DirectoryInfo(path).Parent?.Parent?.Parent;
            DirectoryInfo? dirParentInfo = new DirectoryInfo(path).Parent?.Parent;
            DirectoryInfo? dirInfo = new DirectoryInfo(path).Parent;
            string? dirName = dirInfo?.Name!;
            string? dirParentName = dirParentInfo?.Name!;
            string? dirParentParentName = dirParentParentInfo?.Name!;
            string? dirParentParentParentName = dirParentParentParentInfo?.Name!;
            string imgName = Path.GetFileName(path);
            string specificOutputDirectory = Path.Combine(OutputDirectory, dirParentParentParentName, dirParentParentName, dirParentName, dirName);

            NewImageWrite.DirrectoryCreate(specificOutputDirectory, newImg, imgName);
        }
    }
}ØOriginalContent¿™SelectionsëÉ•Caret¿•StartÕR‡£EndÕg"®FilePathŸxD:\Project\AI_ML_DS\Minor_Project_Ai_Plant_Recognition\Minor_Project_Ai_Plant_Recognition\SorceCode\DataPreprocessing.cs®Language¢C#ëíìÅ•Value Ÿ'no at code "PythonEngine.Initialize();"¿®ResponseÖßContent⁄ëThe error "Attempted to read or write protected memory" at the line `PythonEngine.Initialize();` could be due to a few reasons:

1. **Python Environment**: Ensure that the Python environment you're pointing to is correctly installed and configured. The Python DLL and the Python home path should be correctly set.

2. **Multithreading**: If you're running this code in multiple threads, you need to ensure that each thread has its own Python environment. Python's Global Interpreter Lock (GIL) allows only one thread to execute Python code at a time. You can use `PythonEngine.BeginAllowThreads` and `PythonEngine.EndAllowThreads` to manage the GIL.

3. **Multiple Initializations**: The Python engine should be initialized only once. If you're initializing it multiple times, it might cause issues. You can check if the Python engine is already initialized using `PythonEngine.IsInitialized`.

Here's how you can modify your code:

```csharp
if (!PythonEngine.IsInitialized)
{
    PythonEngine.Initialize();
}
```

4. **Memory management**: The Python engine might be trying to access memory that has been deallocated. Make sure you're not disposing of any objects that are still in use by the Python engine.

Without more information about your Python environment and how you're using the Python engine, it's hard to give a more specific solution. But these are some general tips that might help you troubleshoot the issue.§Type ¶StatusØFollowUpPromptsíŸPHow can I check if the Python environment is correctly installed and configured?ŸCan you provide an example of how to use `PythonEngine.BeginAllowThreads` and `PythonEngine.EndAllowThreads` to manage the GIL?≥CodeVulnerabilitiesê∂LoggedSkillInvocations¿Ü®DateTime◊ˇO¿f(∏™ThreadName¿∞CopilotSessionIdÇ§GuidŸ$64b71c8f-ffb9-409f-957d-1086d9b01afb®ClientIdÅ¢IdŸ4Microsoft.VisualStudio.Conversations.Chat.HelpWindowßRequestÅßRequestïŸ$f666fc03-e84c-4a37-8437-d1b599776027Ÿ$d2f1992f-44ac-4324-b5f5-5c5a43892706êëíìÅ•Value Ÿjwhat if instead of applying task at C# code, i implement it in python script
does it speed up the process¿®ResponseÖßContent⁄vYes, implementing parallel processing directly in your Python script could potentially speed up the process, especially if the tasks are CPU-bound and can be executed independently. Python has several libraries for parallel processing, such as `multiprocessing`, `concurrent.futures`, and `joblib`.

However, there are a few things to consider:

1. **Global Interpreter Lock (GIL)**: Python's GIL allows only one thread to execute Python bytecode at a time, even on multi-core systems. If your tasks are CPU-bound, using threads in Python might not give you a significant speedup. The `multiprocessing` module can bypass the GIL because it uses separate processes instead of threads, but it has a higher overhead because it needs to serialize and deserialize data to communicate between processes.

2. **I/O-bound vs CPU-bound**: If your tasks are I/O-bound (e.g., downloading files, reading from a database), then using threads can give you a significant speedup because while one thread is waiting for I/O, other threads can continue executing. If your tasks are CPU-bound, then using processes (e.g., with the `multiprocessing` module) can give you a speedup.

3. **Data sharing**: If your tasks need to share a large amount of data, then using threads might be more efficient because they share the same memory space. If you use processes, you'll need to serialize and deserialize data to share it between processes, which can be slow for large amounts of data.

4. **Error handling**: Error handling can be more complex with parallel processing because an error in one thread or process can affect other threads or processes.

Here's an example of how you can use the `multiprocessing` module in Python:

```python
from multiprocessing import Pool

def remove_background(image_path):
    # your code here

if __name__ == '__main__':
    with Pool() as p:
        p.map(remove_background, list_of_image_paths)
```

This code creates a pool of worker processes, and each process applies the `remove_background` function to a different image path in `list_of_image_paths`. The `map` function automatically handles dividing the work among the processes in the pool.§Type ¶StatusØFollowUpPromptsíŸ;How can I handle errors in parallel processing with Python?ŸfCan you provide an example of using the `concurrent.futures` module for parallel processing in Python?≥CodeVulnerabilitiesê∂LoggedSkillInvocations¿Ü®DateTime◊ˇTêf(∏t™ThreadName¿∞CopilotSessionIdÇ§GuidŸ$64b71c8f-ffb9-409f-957d-1086d9b01afb®ClientIdÅ¢IdŸ4Microsoft.VisualStudio.Conversations.Chat.HelpWindowßRequestÅßRequestïŸ$6a8a53a1-6dc9-40a9-95ba-92834d98603dŸ$674b2a06-0263-4d6b-b7d0-d032598354fcëÜØProviderMonikerÇ§NameŸ6Microsoft.VisualStudio.Copilot.DocumentContextProviderßVersion£0.1¶Member§file©CanReduce√©RequestIdŸ$6a8a53a1-6dc9-40a9-95ba-92834d98603d©Reference¿•Value»†dŸëMicrosoft.VisualStudio.Copilot.DocumentContext, Microsoft.VisualStudio.Copilot, Version=0.2.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3aÖßContent⁄;from rembg import remove
from PIL import Image
from io import BytesIO
import numpy as np
import os

def remove_backgrnd(image_path, image_output_path):
    """
    Function to remove the background of an image.

    Parameters:
    image_path (str): The path of the image file from which the background is to be removed.
    image_output_path (str): The path where the image with the background removed is to be saved.

    Returns:
    None
    """
    with open(image_path, "rb") as input_img_file:
        input_img = input_img_file.read()
        back_remove = remove(input_img, alpha_matting_background_threshold=200)

        img = Image.open(BytesIO(back_remove)).convert("RGB")

        os.makedirs(os.path.dirname(image_output_path), exist_ok=True)

        img.save(image_output_path, "JPEG")ØOriginalContent¿™SelectionsëÉ•Caret¿•Start £EndÕ;®FilePathŸxD:\Project\AI_ML_DS\Minor_Project_Ai_Plant_Recognition\Minor_Project_Ai_Plant_Recognition\SorceCode\remove_background.py®Language¶PythonëíìÅ•Value Ÿ here i want to implement it here¿®ResponseÖßContent⁄ÅTo implement parallel processing in your Python script, you can use the `multiprocessing` module. Here's how you can modify your script:

```python
from rembg import remove
from PIL import Image
from io import BytesIO
import numpy as np
import os
from multiprocessing import Pool

def remove_backgrnd(args):
    """
    Function to remove the background of an image.

    Parameters:
    args (tuple): A tuple containing the path of the image file from which the background is to be removed and the path where the image with the background removed is to be saved.

    Returns:
    None
    """
    image_path, image_output_path = args
    with open(image_path, "rb") as input_img_file:
        input_img = input_img_file.read()
        back_remove = remove(input_img, alpha_matting_background_threshold=200)

        img = Image.open(BytesIO(back_remove)).convert("RGB")

        os.makedirs(os.path.dirname(image_output_path), exist_ok=True)

        img.save(image_output_path, "JPEG")

if __name__ == '__main__':
    # list_of_image_paths is a list of tuples, where each tuple contains the input and output paths for an image
    list_of_image_paths = [('input1.jpg', 'output1.jpg'), ('input2.jpg', 'output2.jpg'), ...]

    with Pool() as p:
        p.map(remove_backgrnd, list_of_image_paths)
```

This code creates a pool of worker processes, and each process applies the `remove_backgrnd` function to a different pair of image paths in `list_of_image_paths`. The `map` function automatically handles dividing the work among the processes in the pool.

Please replace `list_of_image_paths` with the actual list of tuples of your input and output image paths.§Type ¶StatusØFollowUpPromptsíŸ4How can I handle errors in the multiprocessing pool?Ÿ7What should I do if the number of images is very large?≥CodeVulnerabilitiesê∂LoggedSkillInvocations¿Ü®DateTime◊ˇ≤|L f(∏„™ThreadName¿∞CopilotSessionIdÇ§GuidŸ$64b71c8f-ffb9-409f-957d-1086d9b01afb®ClientIdÅ¢IdŸ4Microsoft.VisualStudio.Conversations.Chat.HelpWindowßRequestÅßRequestïŸ$05660698-9283-4e53-9429-fe19d3f48495Ÿ$c408933f-5283-481d-9fa2-82f8bff6c01eëÜØProviderMonikerÇ§NameŸ6Microsoft.VisualStudio.Copilot.DocumentContextProviderßVersion£0.1¶Member§file©CanReduce√©RequestIdŸ$05660698-9283-4e53-9429-fe19d3f48495©Reference¿•Value»ÉádŸëMicrosoft.VisualStudio.Copilot.DocumentContext, Microsoft.VisualStudio.Copilot, Version=0.2.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3aÖßContent⁄Ç$using Emgu.CV;
using Emgu.CV.CvEnum;
using Emgu.CV.Util;
using Python.Runtime;
using System.Drawing;

namespace Minor_Project_Ai_Plant_Recognition.SorceCode.Preprocessing
{
    /// <summary>
    /// This class is responsible for parsing images from the given directory path.
    /// It writes the paths of the images to a text file.
    /// </summary>
    internal class ImageAccess
    {
        /// <summary>
        /// Parses the directories for image files and writes their paths to a text file.
        /// </summary>
        /// <param name="path">The base path of the directories.</param>
        /// <param name="pathTextFile">The path of the text file to write to.</param>
        public void DirectoryParser(string path, string pathTextFile, string action)
        {
            string[] directories;
            List<string> directoriesList = pathMakerBasedOnAction(path, action);
            directories = directoriesList.ToArray();

            Directory.CreateDirectory(pathTextFile);

            if (action == "Augment" || action == "BckgrndRemove" || action == "Normalization")
            {
                DirParserByImgDim(directories, pathTextFile);
            }
            else if (action == "Resize" || action == "parse")
            {
                DirParserByClass(directories, pathTextFile);
            }
            else
            {
                throw new ArgumentOutOfRangeException($"The action '{action}' does not exist.");
            }
        }

        public void DirParserByClass(string[] directories, string pathTextFile)
        {
            if (File.Exists(Path.Combine(pathTextFile, "dataset_base.txt")))
            {
                File.Delete(Path.Combine(pathTextFile, "dataset_base.txt"));
            }
            using (StreamWriter writer = new(Path.Combine(pathTextFile, "dataset_base.txt"), true))
            {
                foreach (string directory in directories)
                {
                    if (!Directory.Exists(directory))
                    {
                        throw new DirectoryNotFoundException($"The directory '{directory}' does not exist.");
                    }

                    foreach (string subdirectory in Directory.EnumerateDirectories(directory))
                    {
                        foreach (string filePath in Directory.EnumerateFiles(subdirectory))
                        {
                            string extension = Path.GetExtension(filePath);
                            if (extension == ".jpg" || extension == ".png")
                            {
                                writer.WriteLine(filePath);
                            }
                        }
                    }
                }
            }
        }

        public void DirParserByImgDim(string[] directories, string pathTextFile)
        {
            //using (StreamWriter writer = new(Path.Combine(pathTextFile, $"dataset_.{parentName}txt"), false))
            if (File.Exists(Path.Combine(pathTextFile, $"dataset_size224_224.txt")))
            {
                File.Delete(Path.Combine(pathTextFile, $"dataset_size224_224.txt"));
            }
            if (File.Exists(Path.Combine(pathTextFile, $"dataset_size299_299.txt")))
            {
                File.Delete(Path.Combine(pathTextFile, $"dataset_size299_299.txt"));
            }

            foreach (string directory in directories)
            {
                if (new DirectoryInfo(directory).Parent!.Name == "size224_224")
                {
                    if (!Directory.Exists(directory))
                    {
                        throw new DirectoryNotFoundException($"The directory '{directory}' does not exist.");
                    }
                    using (StreamWriter writer = new(Path.Combine(pathTextFile, $"dataset_size224_224.txt"), true))
                    {
                        foreach (string subdirectory in Directory.EnumerateDirectories(directory))
                        {
                            foreach (string filePath in Directory.EnumerateFiles(subdirectory))
                            {
                                string extension = Path.GetExtension(filePath);
                                if (extension == ".jpg" || extension == ".png")
                                {
                                    writer.WriteLine(filePath);
                                }
                            }
                        }
                    }
                }
                else if (new DirectoryInfo(directory).Parent!.Name == "size299_299")
                {
                    if (!Directory.Exists(directory))
                    {
                        throw new DirectoryNotFoundException($"The directory '{directory}' does not exist.");
                    }
                    using (StreamWriter writer = new(Path.Combine(pathTextFile, $"dataset_size299_299.txt"), true))
                    {
                        foreach (string subdirectory in Directory.EnumerateDirectories(directory))
                        {
                            foreach (string filePath in Directory.EnumerateFiles(subdirectory))
                            {
                                string extension = Path.GetExtension(filePath);
                                if (extension == ".jpg" || extension == ".png")
                                {
                                    writer.WriteLine(filePath);
                                }
                            }
                        }
                    }
                }
                else
                {
                    throw new DirectoryNotFoundException($"The directory does not exist.");
                }
            }
        }

        /// <summary>
        /// Constructs a list of directories based on the specified action.
        /// </summary>
        /// <param name="path">The base path to use when constructing the directories.</param>
        /// <param name="action">The action to base the directories on. Can be "resize", "parse", or "Augment".</param>
        /// <returns>A list of directories constructed based on the specified action.</returns>
        public List<string> pathMakerBasedOnAction(string path, string action)
        {
            List<string> directories = new List<string>();
            List<string> tempDir = new List<string>();

            if (action == "Resize" || action == "parse")
            {
                directories.Add(Path.Combine(path, "Medicinal_Leaf_dataset"));
                directories.Add(Path.Combine(path, "Medicinal_plant_dataset"));
            }
            else if (action == "Augment")
            {
                tempDir.Add(Path.Combine(path, "size224_224"));
                tempDir.Add(Path.Combine(path, "size299_299"));

                foreach (string dir in tempDir.ToList()) // Use ToList to create a copy for iteration
                {
                    directories.AddRange(pathMakerBasedOnAction(dir, "parse"));
                }
            }
            else if (action == "BckgrndRemove")
            {
                List<string> dirNames = new List<string> { "flipped", "noised", "resized", "rotated", "translated" };
                List<string> dimension = new List<string> { "size224_224", "size299_299" };
                foreach (string dirName in dirNames)
                {
                    foreach (string dim in dimension)
                    {
                        tempDir.Add(Path.Combine(path, dirName, dim));
                    }
                }

                foreach (string dir in tempDir.ToList()) // Use ToList to create a copy for iteration
                {
                    directories.AddRange(pathMakerBasedOnAction(dir, "parse"));
                }
            }
            else if (action == "Normalization")
            {
                List<string> dirNames = new List<string> { "flipped", "noised", "resized", "rotated", "translated" };
                List<string> dimension = new List<string> { "size224_224", "size299_299" };
                foreach (string dirName in dirNames)
                {
                    foreach (string dim in dimension)
                    {
                        tempDir.Add(Path.Combine(path, dirName, dim));
                    }
                }

                foreach (string dir in tempDir.ToList()) // Use ToList to create a copy for iteration
                {
                    directories.AddRange(pathMakerBasedOnAction(dir, "parse"));
                }
            }
            return directories;
        }
    }

    /// <summary>
    /// This class is responsible for writing images to a directory.
    /// </summary>
    internal class NewImageWrite
    {
        /// <summary>
        /// Creates a directory and writes an image to it.
        /// </summary>
        /// <param name="path">The path of the directory to create.</param>
        /// <param name="newImg">The image to write.</param>
        /// <param name="imgName">The name of the image file.</param>
        public static void DirrectoryCreate(string path, Mat newImg, string imgName)
        {
            if (!Directory.Exists(path))
            {
                try
                {
                    Directory.CreateDirectory(path);
                }
                catch (Exception e)
                {
                    Console.WriteLine($"Failed to create directory: {e}");
                }
            }

            WriteImage(path, newImg, imgName);
        }

        /// <summary>
        /// Writes an image to a file.
        /// </summary>
        /// <param name="path">The path of the file to write to.</param>
        /// <param name="newImg">The image to write.</param>
        /// <param name="imgName">The name of the image file.</param>
        private static void WriteImage(string path, Mat newImg, string imgName)
        {
            string newPath = Path.Combine(path, imgName);

            try
            {
                CvInvoke.Imwrite(newPath, newImg);
            }
            catch (IOException e)
            {
                Console.WriteLine("In NewImageWriter");
                Console.WriteLine($"Failed to write image: {e}");
            }
        }
    }

    /// <summary>
    /// This class is responsible for resizing images.
    /// </summary>
    internal class ImageResize
    {
        /// <summary>
        /// The directory to output the resized images to.
        /// </summary>
        public string OutputDirectory { get; } = "D:\\Project\\AI_ML_DS\\Minor_Project_Ai_Plant_Recognition\\Minor_Project_Ai_Plant_Recognition\\Data\\Dataset(resized)";

        private readonly NewImageWrite _newImageWrite = new NewImageWrite();

        /// <summary>
        /// Resizes the images specified in the text file at the given path.
        /// </summary>
        /// <param name="path">The path of the text file containing the image paths.</param>
        public void ResizeFactory(string path)
        {
            string textPath = Path.Combine(path, "dataset_base.txt");

            ResizeDirectory(textPath, 224, 224);
            ResizeDirectory(textPath, 299, 299);
        }

        public void ResizeDirectory(string path, int width, int height)
        {
            var lines = File.ReadLines(path);
            Parallel.ForEach(lines, (line) =>
            {
                Resizer(line, width, height);
            });
        }

        /// <summary>
        /// Resizes an image to the specified width and height.
        /// </summary>
        /// <param name="path">The path of the image to resize.</param>
        /// <param name="width">The width to resize to.</param>
        /// <param name="height">The height to resize to.</param>
        private void Resizer(string path, int width, int height)
        {
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);
            Mat resizedImage = new Mat();
            CvInvoke.Resize(image, resizedImage, new Size(width, height), 0, 0, Inter.Area);

            ImageWriterAssistance(path, resizedImage, width, height);
        }

        /// <summary>
        /// Assists in writing the resized image to the output directory.
        /// </summary>
        /// <param name="path">The path of the original image.</param>
        /// <param name="newImg">The resized image.</param>
        /// <param name="width">The width of the resized image.</param>
        /// <param name="height">The height of the resized image.</param>
        private void ImageWriterAssistance(string path, Mat newImg, int width, int height)
        {
            DirectoryInfo? dirParentInfo = new DirectoryInfo(path).Parent?.Parent;
            DirectoryInfo? dirInfo = new DirectoryInfo(path).Parent;
            string? dirName = dirInfo?.Name!;
            string? dirParentName = dirParentInfo?.Name!;
            string imgName = Path.GetFileName(path);
            string specificOutputDirectory = Path.Combine(OutputDirectory, $"size{width}_{height}", dirParentName, dirName);

            NewImageWrite.DirrectoryCreate(specificOutputDirectory, newImg, imgName);
        }
    }

    /// <summary>
    /// This class is responsible for Data Augmentation.
    /// </summary>
    internal class DataAugmentation
    {
        private readonly NewImageWrite _newImageWrite = new NewImageWrite();

        /// <summary>
        /// Augments the images specified in the text file at the given path.
        /// </summary>
        /// <param name="path">The path of the text file containing the image paths.</param>
        public void AugmentFactory(string path)
        {
            string path224 = Path.Combine(path, "dataset_size224_224.txt");
            string path299 = Path.Combine(path, "dataset_size299_299.txt");

            Task path224Task = Task.Run(() => AugmentDirectory(path224, "224Task"));
            Task path299Task = Task.Run(() => AugmentDirectory(path299, "299Task"));

            Task.WaitAll(path224Task, path299Task);
        }

        public void AugmentDirectory(string path, string taskName)
        {
            if (taskName == "224Task")
            {
                int totalLines = File.ReadLines(path).Count();
                {
                    using (StreamReader reader = new StreamReader(path))
                    {
                        string line;
                        while ((line = reader.ReadLine()!) != null)
                        {
                            FlipAugmenter(line);
                            RotateAugmenter(line);
                            NoiseAugmenter(line);
                            TranslateAugmenter(line);
                            CopyResizedImage(line);
                        }
                    }
                }
            }
            else if (taskName == "299Task")
            {
                int totalLines = File.ReadLines(path).Count();
                {
                    using (StreamReader reader = new StreamReader(path))
                    {
                        string line;
                        while ((line = reader.ReadLine()!) != null)
                        {
                            FlipAugmenter(line);
                            RotateAugmenter(line);
                            NoiseAugmenter(line);
                            TranslateAugmenter(line);
                            CopyResizedImage(line);
                        }
                    }
                }
            }
            else
            {
                throw new ArgumentOutOfRangeException($"The task '{taskName}' does not exist.");
            }
        }

        /// <summary>
        /// Augments an image by flipping it.
        /// </summary>
        /// <param name="path">The path of the image to augment.</param>
        private void FlipAugmenter(string path)
        {
            string action = "flipped";
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);
            Mat flippedImage = new Mat();
            CvInvoke.Flip(image, flippedImage, FlipType.Both);

            ImageWriterAssistance(path, flippedImage, action);
        }

        /// <summary>
        /// Augments an image by rotating it.
        /// </summary>
        /// <param name="path">The path of the image to augment.</param>
        private void RotateAugmenter(string path)
        {
            string action = "rotated";
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);
            Mat rotatedImage = new Mat();
            CvInvoke.Rotate(image, rotatedImage, RotateFlags.Rotate90Clockwise);

            ImageWriterAssistance(path, rotatedImage, action);
        }

        /// <summary>
        /// Augments an image by adding noise to it.
        /// </summary>
        /// <param name="path">The path of the image to augment.</param>
        private void NoiseAugmenter(string path)
        {
            string action = "noised";
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);
            Mat noisedImage = new Mat();
            CvInvoke.GaussianBlur(image, noisedImage, new Size(5, 5), 0);

            ImageWriterAssistance(path, noisedImage, action);
        }

        /// <summary>
        /// Augments an image by translating it.
        /// </summary>
        /// <param name="path">The path of the image to augment.</param>
        private void TranslateAugmenter(string path)
        {
            string action = "translated";
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);
            int imageWidth = image.Width;
            int imageHeight = image.Height;
            Mat translatedImage = new Mat();
            Matrix<float> shiftMatrix = new Matrix<float>(2, 3);
            Random rand = new Random();
            int shiftX = rand.Next(-50, 50);  // Random shift in x direction between -50 and 50
            int shiftY = rand.Next(-50, 50);  // Random shift in y direction between -50 and 50

            shiftMatrix[0, 0] = 1;  // Identity element
            shiftMatrix[1, 1] = 1;  // Identity element
            shiftMatrix[0, 2] = shiftX;  // Shift in x direction
            shiftMatrix[1, 2] = shiftY;  // Shift in y direction
            CvInvoke.WarpAffine(image, translatedImage, shiftMatrix, new Size(imageWidth, imageHeight), 0);

            ImageWriterAssistance(path, translatedImage, action);
        }

        /// <summary>
        /// Augments an image by copying it to the output directory.
        /// </summary>
        /// <param name="path"></param>
        private void CopyResizedImage(string path)
        {
            string action = "resized";
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);
            Mat copyResizedImage = image;

            ImageWriterAssistance(path, copyResizedImage, action);
        }

        /// <summary>
        /// The directory to output the augmented images to.
        /// </summary>
        public string OutputDirectory { get; } = "D:\\Project\\AI_ML_DS\\Minor_Project_Ai_Plant_Recognition\\Minor_Project_Ai_Plant_Recognition\\Data\\Dataset(augmented)";

        /// <summary>
        /// Assists in writing the augmented image to the output directory.
        /// </summary>
        /// <param name="path">The path of the original image.</param>
        /// <param name="newImg">The augmented image.</param>
        private void ImageWriterAssistance(string path, Mat newImg, string action)
        {
            DirectoryInfo? directoryParentParentInfo = new DirectoryInfo(path).Parent?.Parent?.Parent;
            DirectoryInfo? dirParentInfo = new DirectoryInfo(path).Parent?.Parent;
            DirectoryInfo? dirInfo = new DirectoryInfo(path).Parent;
            string? dirName = dirInfo?.Name!;
            string? dirParentName = dirParentInfo?.Name!;
            string? dirParentParentName = directoryParentParentInfo?.Name!;
            string imgName = Path.GetFileName(path);
            string specificOutputDirectory = Path.Combine(OutputDirectory, action, dirParentParentName, dirParentName, dirName);

            NewImageWrite.DirrectoryCreate(specificOutputDirectory, newImg, imgName);
        }
    }

    /// <summary>
    /// This class is responsible for removing the background from images.
    /// </summary>
    internal class BckgrndRemover
    {
        private readonly NewImageWrite _newImageWrite = new NewImageWrite();

        /// <summary>
        /// Removes the background from the images specified in the text file at the given path.
        /// </summary>
        /// <param name="path">The path of the text file containing the image paths.</param>
        public void RemoveBackgroundFactory(string path)
        {
            string path224 = Path.Combine(path, "dataset_size224_224.txt");
            string path299 = Path.Combine(path, "dataset_size299_299.txt");

            Task path224Task = Task.Run(() => BackGrndRemoveDirectory(path224, "224Task"));
            Task path299Task = Task.Run(() => BackGrndRemoveDirectory(path299, "299Task"));

            Task.WaitAll(path224Task, path299Task);
            //// Path to the Python DLL
            //Runtime.PythonDLL = @"C:\Users\kumar\AppData\Local\Programs\Python\Python312\python312.dll";
            //// Setting the PYTHONHOME environment variable
            //Environment.SetEnvironmentVariable("PYTHONHOME", @"C:\Users\kumar\AppData\Local\Programs\Python\Python312", EnvironmentVariableTarget.Process);

            //try
            //{
            //    // Initialize the Python Engine
            //    PythonEngine.Initialize();

            //    int totalLines = File.ReadLines(Path.Combine(path, "dataset.txt")).Count();
            //    using (var pbar = new ProgressBar(totalLines, "Removing Background", new ProgressBarOptions { ProgressCharacter = '#' }))
            //    {
            //        using (StreamReader reader = new StreamReader(Path.Combine(path, "dataset.txt")))
            //        {
            //            string line;
            //            while ((line = reader.ReadLine()!) != null)
            //            {
            //                PythonScriptRemoveBackground(line);
            //                pbar.Tick();
            //            }
            //        }
            //    }
            //}
            //catch (Exception e)
            //{
            //    Console.WriteLine($"Failed to remove background: {e.Message}");
            //}
            //finally
            //{
            //    // Shutdown the Python Engine
            //    PythonEngine.Shutdown();
            //}
        }

        private void BackGrndRemoveDirectory(string path, string taskName)
        {
            // Path to the Python DLL
            Runtime.PythonDLL = @"C:\Users\kumar\AppData\Local\Programs\Python\Python312\python312.dll";
            // Setting the PYTHONHOME environment variable
            Environment.SetEnvironmentVariable("PYTHONHOME", @"C:\Users\kumar\AppData\Local\Programs\Python\Python312", EnvironmentVariableTarget.Process);

            try
            {
                PythonEngine.Initialize();

                if (taskName == "224Task")
                {
                    int totalLines = File.ReadLines(path).Count();
                    {
                        using (StreamReader reader = new StreamReader(path))
                        {
                            string line;
                            while ((line = reader.ReadLine()!) != null)
                            {
                                PythonScriptRemoveBackground(line);
                            }
                        }
                    }
                }
                else if (taskName == "299Task")
                {
                    int totalLines = File.ReadLines(path).Count();
                    {
                        using (StreamReader reader = new StreamReader(path))
                        {
                            string line;
                            while ((line = reader.ReadLine()!) != null)
                            {
                                PythonScriptRemoveBackground(line);
                            }
                        }
                    }
                }
                else
                {
                    throw new ArgumentOutOfRangeException($"The task '{taskName}' does not exist.");
                }
            }
            catch (Exception e)
            {
                Console.WriteLine($"Failed to remove background: {e.Message}");
            }
            finally
            {
                // Shutdown the Python Engine
                PythonEngine.Shutdown();
            }
        }

        /// <summary>
        /// Executes a Python script to remove the background from an image.
        /// </summary>
        /// <param name="path">The path of the image to process.</param>
        private void PythonScriptRemoveBackground(string path)
        {
            using (Py.GIL())
            {
                // Get the output path for the processed image
                string outputPath = ImageWriterAssistance(path);

                // Read the Python script
                string pythonScript = System.IO.File.ReadAllText(@"D:\Project\AI_ML_DS\Minor_Project_Ai_Plant_Recognition\Minor_Project_Ai_Plant_Recognition\SorceCode\remove_background.py");
                // Run the Python script
                PythonEngine.RunSimpleString(pythonScript);
                // Call the remove_backgrnd function from the Python script
                dynamic removeBackground = PythonEngine.RunSimpleString($"remove_backgrnd(r'{path}', r'{outputPath}')");
            }
        }

        /// <summary>
        /// The directory to output the images with the background removed to.
        /// </summary>
        public string OutputDirectory { get; } = "D:\\Project\\AI_ML_DS\\Minor_Project_Ai_Plant_Recognition\\Minor_Project_Ai_Plant_Recognition\\Data\\Dataset(background_removed)";

        /// <summary>
        /// Assists in writing the image with the background removed to the output directory.
        /// </summary>
        /// <param name="path">The path of the original image.</param>
        /// <param name="newImg">The image with the background removed.</param>
        private string ImageWriterAssistance(string path)
        {
            DirectoryInfo? dirParentParentParentInfo = new DirectoryInfo(path).Parent?.Parent?.Parent?.Parent;
            DirectoryInfo? dirParentParentInfo = new DirectoryInfo(path).Parent?.Parent?.Parent;
            DirectoryInfo? dirParentInfo = new DirectoryInfo(path).Parent?.Parent;
            DirectoryInfo? dirInfo = new DirectoryInfo(path).Parent;
            string? dirName = dirInfo?.Name!;
            string? dirParentName = dirParentInfo?.Name!;
            string? dirParentParentName = dirParentParentInfo?.Name!;
            string? dirParentParentParentName = dirParentParentParentInfo?.Name!;
            string imgName = Path.GetFileName(path);
            string specificOutputDirectory = Path.Combine(OutputDirectory, dirParentParentParentName, dirParentParentName, dirParentName, dirName);

            return Path.Combine(specificOutputDirectory, imgName);
            // Regular image write is not needed.
            //_newImageWrite.DirrectoryCreate(specificOutputDirectory, newImg, imgName);
        }
    }

    /// <summary>
    /// This class is responsble for normalization of images data.
    /// </summary>
    internal class Normalization
    {
        private readonly NewImageWrite _newImageWrite = new NewImageWrite();

        /// <summary>
        /// Normalizes the images specified in the text file at the given path.
        /// </summary>
        /// <param name="path">The path of the text file containing the image paths.</param>
        public void NormalizationFactor(string path)
        {
            string path224 = Path.Combine(path, "dataset_size224_224.txt");
            string path299 = Path.Combine(path, "dataset_size299_299.txt");

            Task path224Task = Task.Run(() => NormalizeDirectory(path224, "224Task"));
            Task path299Task = Task.Run(() => NormalizeDirectory(path299, "299Task"));

            Task.WaitAll(path224Task, path299Task);
            //int totalLines = File.ReadLines(Path.Combine(path, "dataset.txt")).Count();

            //using (var pbar = new ProgressBar(totalLines, "Resizing", new ProgressBarOptions { ProgressCharacter = '#' }))
            //{
            //    using (StreamReader reader = new StreamReader(Path.Combine(path, "dataset.txt")))
            //    {
            //        string line;
            //        while ((line = reader.ReadLine()!) != null)
            //        {
            //            NormalizeColorWise(line);
            //            pbar.Tick();
            //        }
            //    }
            //}
        }

        private void NormalizeDirectory(string path, string taskName)
        {
            if (taskName == "224Task")
            {
                int totalLines = File.ReadLines(path).Count();
                {
                    using (StreamReader reader = new StreamReader(path))
                    {
                        string line;
                        while ((line = reader.ReadLine()!) != null)
                        {
                            NormalizeColorWise(line);
                        }
                    }
                }
            }
            else if (taskName == "299Task")
            {
                int totalLines = File.ReadLines(path).Count();
                {
                    using (StreamReader reader = new StreamReader(path))
                    {
                        string line;
                        while ((line = reader.ReadLine()!) != null)
                        {
                            NormalizeColorWise(line);
                        }
                    }
                }
            }
            else
            {
                throw new ArgumentOutOfRangeException($"The task '{taskName}' does not exist.");
            }
        }

        /// <summary>
        /// Normalizes an image using min-max.
        /// </summary>
        /// <param name="path">The path of the image to process.</param>
        public void NormalizeColorWise(string path)
        {
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);

            Mat normalizedImage = image.Clone();
            VectorOfMat vm = new VectorOfMat();
            CvInvoke.Split(image, vm);

            for (int i = 0; i < vm.Size; i++)
            {
                Mat channel = vm[i];
                CvInvoke.Normalize(channel, channel, 0, 255, NormType.MinMax);
            }
            CvInvoke.Merge(vm, normalizedImage);

            ImageWriterAssistance(path, normalizedImage);
        }

        /// <summary>
        /// The directory to output the normalized images to the directory.
        /// </summary>
        public string OutputDirectory { get; } = "D:\\Project\\AI_ML_DS\\Minor_Project_Ai_Plant_Recognition\\Minor_Project_Ai_Plant_Recognition\\Data\\Dataset(normalized)";

        /// <summary>
        /// Assists in writing the normalized image to the output directory.
        /// </summary>
        /// <param name="path">The path of the original image.</param>
        /// <param name="newImg">The image with the background removed.</param>

        private void ImageWriterAssistance(string path, Mat newImg)
        {
            DirectoryInfo? dirParentParentParentInfo = new DirectoryInfo(path).Parent?.Parent?.Parent?.Parent;
            DirectoryInfo? dirParentParentInfo = new DirectoryInfo(path).Parent?.Parent?.Parent;
            DirectoryInfo? dirParentInfo = new DirectoryInfo(path).Parent?.Parent;
            DirectoryInfo? dirInfo = new DirectoryInfo(path).Parent;
            string? dirName = dirInfo?.Name!;
            string? dirParentName = dirParentInfo?.Name!;
            string? dirParentParentName = dirParentParentInfo?.Name!;
            string? dirParentParentParentName = dirParentParentParentInfo?.Name!;
            string imgName = Path.GetFileName(path);
            string specificOutputDirectory = Path.Combine(OutputDirectory, dirParentParentParentName, dirParentParentName, dirParentName, dirName);

            NewImageWrite.DirrectoryCreate(specificOutputDirectory, newImg, imgName);
        }
    }
}ØOriginalContent¿™SelectionsëÉ•Caret¿•StartÕR‡£EndÕg"®FilePathŸxD:\Project\AI_ML_DS\Minor_Project_Ai_Plant_Recognition\Minor_Project_Ai_Plant_Recognition\SorceCode\DataPreprocessing.cs®Language¢C#ëíìÅ•Value Ÿ[how to implement it here in C#, currently task is giving error at pythonEngine.Initialize()¿®ResponseÖßContent⁄√The error at `PythonEngine.Initialize()` is likely due to the Python engine being initialized multiple times in different threads. The Python engine should be initialized only once, and each thread should have its own Python environment.

To fix this, you can use `PythonEngine.BeginAllowThreads()` to get a Python thread state that you can use to initialize the Python engine in each thread. Here's how you can modify your code:

```csharp
public void RemoveBackgroundFactory(string path)
{
    string path224 = Path.Combine(path, "dataset_size224_224.txt");
    string path299 = Path.Combine(path, "dataset_size299_299.txt");

    // Initialize the Python engine
    if (!PythonEngine.IsInitialized)
    {
        PythonEngine.Initialize();
    }

    // Get a Python thread state
    var pyThreadState = PythonEngine.BeginAllowThreads();

    Task path224Task = Task.Run(() =>
    {
        // Use the Python thread state in this thread
        PythonEngine.BeginThread(pyThreadState);
        BackGrndRemoveDirectory(path224, "224Task");
        PythonEngine.EndThread();
    });

    Task path299Task = Task.Run(() =>
    {
        // Use the Python thread state in this thread
        PythonEngine.BeginThread(pyThreadState);
        BackGrndRemoveDirectory(path299, "299Task");
        PythonEngine.EndThread();
    });

    Task.WaitAll(path224Task, path299Task);

    // End the use of the Python thread state
    PythonEngine.EndAllowThreads(pyThreadState);
}
```

This code initializes the Python engine once and gets a Python thread state using `PythonEngine.BeginAllowThreads()`. Then, it uses this thread state to initialize the Python engine in each thread. After the tasks are done, it ends the use of the Python thread state with `PythonEngine.EndAllowThreads(pyThreadState)`.

Please note that this code assumes that `BackGrndRemoveDirectory` and any other methods it calls are thread-safe. If they're not, you'll need to add synchronization to prevent race conditions.§Type ¶StatusØFollowUpPromptsíŸJHow can I ensure that the methods called within the tasks are thread-safe?ŸVCan I use the same approach to initialize the Python engine in other parts of my code?≥CodeVulnerabilitiesê∂LoggedSkillInvocations¿Ü®DateTime◊ˇWß2`f(πr™ThreadName¿∞CopilotSessionIdÇ§GuidŸ$64b71c8f-ffb9-409f-957d-1086d9b01afb®ClientIdÅ¢IdŸ4Microsoft.VisualStudio.Conversations.Chat.HelpWindowßRequestÅßRequestïŸ$a214d035-7693-4664-b57a-7d46f51db32bŸ$df62dc17-a99a-4612-afdb-f9936ea10f20ëÜØProviderMonikerÇ§NameŸ6Microsoft.VisualStudio.Copilot.DocumentContextProviderßVersion£0.1¶Member§file©CanReduce√©RequestIdŸ$a214d035-7693-4664-b57a-7d46f51db32b©Reference¿•Value»ÉádŸëMicrosoft.VisualStudio.Copilot.DocumentContext, Microsoft.VisualStudio.Copilot, Version=0.2.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3aÖßContent⁄Ç$using Emgu.CV;
using Emgu.CV.CvEnum;
using Emgu.CV.Util;
using Python.Runtime;
using System.Drawing;

namespace Minor_Project_Ai_Plant_Recognition.SorceCode.Preprocessing
{
    /// <summary>
    /// This class is responsible for parsing images from the given directory path.
    /// It writes the paths of the images to a text file.
    /// </summary>
    internal class ImageAccess
    {
        /// <summary>
        /// Parses the directories for image files and writes their paths to a text file.
        /// </summary>
        /// <param name="path">The base path of the directories.</param>
        /// <param name="pathTextFile">The path of the text file to write to.</param>
        public void DirectoryParser(string path, string pathTextFile, string action)
        {
            string[] directories;
            List<string> directoriesList = pathMakerBasedOnAction(path, action);
            directories = directoriesList.ToArray();

            Directory.CreateDirectory(pathTextFile);

            if (action == "Augment" || action == "BckgrndRemove" || action == "Normalization")
            {
                DirParserByImgDim(directories, pathTextFile);
            }
            else if (action == "Resize" || action == "parse")
            {
                DirParserByClass(directories, pathTextFile);
            }
            else
            {
                throw new ArgumentOutOfRangeException($"The action '{action}' does not exist.");
            }
        }

        public void DirParserByClass(string[] directories, string pathTextFile)
        {
            if (File.Exists(Path.Combine(pathTextFile, "dataset_base.txt")))
            {
                File.Delete(Path.Combine(pathTextFile, "dataset_base.txt"));
            }
            using (StreamWriter writer = new(Path.Combine(pathTextFile, "dataset_base.txt"), true))
            {
                foreach (string directory in directories)
                {
                    if (!Directory.Exists(directory))
                    {
                        throw new DirectoryNotFoundException($"The directory '{directory}' does not exist.");
                    }

                    foreach (string subdirectory in Directory.EnumerateDirectories(directory))
                    {
                        foreach (string filePath in Directory.EnumerateFiles(subdirectory))
                        {
                            string extension = Path.GetExtension(filePath);
                            if (extension == ".jpg" || extension == ".png")
                            {
                                writer.WriteLine(filePath);
                            }
                        }
                    }
                }
            }
        }

        public void DirParserByImgDim(string[] directories, string pathTextFile)
        {
            //using (StreamWriter writer = new(Path.Combine(pathTextFile, $"dataset_.{parentName}txt"), false))
            if (File.Exists(Path.Combine(pathTextFile, $"dataset_size224_224.txt")))
            {
                File.Delete(Path.Combine(pathTextFile, $"dataset_size224_224.txt"));
            }
            if (File.Exists(Path.Combine(pathTextFile, $"dataset_size299_299.txt")))
            {
                File.Delete(Path.Combine(pathTextFile, $"dataset_size299_299.txt"));
            }

            foreach (string directory in directories)
            {
                if (new DirectoryInfo(directory).Parent!.Name == "size224_224")
                {
                    if (!Directory.Exists(directory))
                    {
                        throw new DirectoryNotFoundException($"The directory '{directory}' does not exist.");
                    }
                    using (StreamWriter writer = new(Path.Combine(pathTextFile, $"dataset_size224_224.txt"), true))
                    {
                        foreach (string subdirectory in Directory.EnumerateDirectories(directory))
                        {
                            foreach (string filePath in Directory.EnumerateFiles(subdirectory))
                            {
                                string extension = Path.GetExtension(filePath);
                                if (extension == ".jpg" || extension == ".png")
                                {
                                    writer.WriteLine(filePath);
                                }
                            }
                        }
                    }
                }
                else if (new DirectoryInfo(directory).Parent!.Name == "size299_299")
                {
                    if (!Directory.Exists(directory))
                    {
                        throw new DirectoryNotFoundException($"The directory '{directory}' does not exist.");
                    }
                    using (StreamWriter writer = new(Path.Combine(pathTextFile, $"dataset_size299_299.txt"), true))
                    {
                        foreach (string subdirectory in Directory.EnumerateDirectories(directory))
                        {
                            foreach (string filePath in Directory.EnumerateFiles(subdirectory))
                            {
                                string extension = Path.GetExtension(filePath);
                                if (extension == ".jpg" || extension == ".png")
                                {
                                    writer.WriteLine(filePath);
                                }
                            }
                        }
                    }
                }
                else
                {
                    throw new DirectoryNotFoundException($"The directory does not exist.");
                }
            }
        }

        /// <summary>
        /// Constructs a list of directories based on the specified action.
        /// </summary>
        /// <param name="path">The base path to use when constructing the directories.</param>
        /// <param name="action">The action to base the directories on. Can be "resize", "parse", or "Augment".</param>
        /// <returns>A list of directories constructed based on the specified action.</returns>
        public List<string> pathMakerBasedOnAction(string path, string action)
        {
            List<string> directories = new List<string>();
            List<string> tempDir = new List<string>();

            if (action == "Resize" || action == "parse")
            {
                directories.Add(Path.Combine(path, "Medicinal_Leaf_dataset"));
                directories.Add(Path.Combine(path, "Medicinal_plant_dataset"));
            }
            else if (action == "Augment")
            {
                tempDir.Add(Path.Combine(path, "size224_224"));
                tempDir.Add(Path.Combine(path, "size299_299"));

                foreach (string dir in tempDir.ToList()) // Use ToList to create a copy for iteration
                {
                    directories.AddRange(pathMakerBasedOnAction(dir, "parse"));
                }
            }
            else if (action == "BckgrndRemove")
            {
                List<string> dirNames = new List<string> { "flipped", "noised", "resized", "rotated", "translated" };
                List<string> dimension = new List<string> { "size224_224", "size299_299" };
                foreach (string dirName in dirNames)
                {
                    foreach (string dim in dimension)
                    {
                        tempDir.Add(Path.Combine(path, dirName, dim));
                    }
                }

                foreach (string dir in tempDir.ToList()) // Use ToList to create a copy for iteration
                {
                    directories.AddRange(pathMakerBasedOnAction(dir, "parse"));
                }
            }
            else if (action == "Normalization")
            {
                List<string> dirNames = new List<string> { "flipped", "noised", "resized", "rotated", "translated" };
                List<string> dimension = new List<string> { "size224_224", "size299_299" };
                foreach (string dirName in dirNames)
                {
                    foreach (string dim in dimension)
                    {
                        tempDir.Add(Path.Combine(path, dirName, dim));
                    }
                }

                foreach (string dir in tempDir.ToList()) // Use ToList to create a copy for iteration
                {
                    directories.AddRange(pathMakerBasedOnAction(dir, "parse"));
                }
            }
            return directories;
        }
    }

    /// <summary>
    /// This class is responsible for writing images to a directory.
    /// </summary>
    internal class NewImageWrite
    {
        /// <summary>
        /// Creates a directory and writes an image to it.
        /// </summary>
        /// <param name="path">The path of the directory to create.</param>
        /// <param name="newImg">The image to write.</param>
        /// <param name="imgName">The name of the image file.</param>
        public static void DirrectoryCreate(string path, Mat newImg, string imgName)
        {
            if (!Directory.Exists(path))
            {
                try
                {
                    Directory.CreateDirectory(path);
                }
                catch (Exception e)
                {
                    Console.WriteLine($"Failed to create directory: {e}");
                }
            }

            WriteImage(path, newImg, imgName);
        }

        /// <summary>
        /// Writes an image to a file.
        /// </summary>
        /// <param name="path">The path of the file to write to.</param>
        /// <param name="newImg">The image to write.</param>
        /// <param name="imgName">The name of the image file.</param>
        private static void WriteImage(string path, Mat newImg, string imgName)
        {
            string newPath = Path.Combine(path, imgName);

            try
            {
                CvInvoke.Imwrite(newPath, newImg);
            }
            catch (IOException e)
            {
                Console.WriteLine("In NewImageWriter");
                Console.WriteLine($"Failed to write image: {e}");
            }
        }
    }

    /// <summary>
    /// This class is responsible for resizing images.
    /// </summary>
    internal class ImageResize
    {
        /// <summary>
        /// The directory to output the resized images to.
        /// </summary>
        public string OutputDirectory { get; } = "D:\\Project\\AI_ML_DS\\Minor_Project_Ai_Plant_Recognition\\Minor_Project_Ai_Plant_Recognition\\Data\\Dataset(resized)";

        private readonly NewImageWrite _newImageWrite = new NewImageWrite();

        /// <summary>
        /// Resizes the images specified in the text file at the given path.
        /// </summary>
        /// <param name="path">The path of the text file containing the image paths.</param>
        public void ResizeFactory(string path)
        {
            string textPath = Path.Combine(path, "dataset_base.txt");

            ResizeDirectory(textPath, 224, 224);
            ResizeDirectory(textPath, 299, 299);
        }

        public void ResizeDirectory(string path, int width, int height)
        {
            var lines = File.ReadLines(path);
            Parallel.ForEach(lines, (line) =>
            {
                Resizer(line, width, height);
            });
        }

        /// <summary>
        /// Resizes an image to the specified width and height.
        /// </summary>
        /// <param name="path">The path of the image to resize.</param>
        /// <param name="width">The width to resize to.</param>
        /// <param name="height">The height to resize to.</param>
        private void Resizer(string path, int width, int height)
        {
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);
            Mat resizedImage = new Mat();
            CvInvoke.Resize(image, resizedImage, new Size(width, height), 0, 0, Inter.Area);

            ImageWriterAssistance(path, resizedImage, width, height);
        }

        /// <summary>
        /// Assists in writing the resized image to the output directory.
        /// </summary>
        /// <param name="path">The path of the original image.</param>
        /// <param name="newImg">The resized image.</param>
        /// <param name="width">The width of the resized image.</param>
        /// <param name="height">The height of the resized image.</param>
        private void ImageWriterAssistance(string path, Mat newImg, int width, int height)
        {
            DirectoryInfo? dirParentInfo = new DirectoryInfo(path).Parent?.Parent;
            DirectoryInfo? dirInfo = new DirectoryInfo(path).Parent;
            string? dirName = dirInfo?.Name!;
            string? dirParentName = dirParentInfo?.Name!;
            string imgName = Path.GetFileName(path);
            string specificOutputDirectory = Path.Combine(OutputDirectory, $"size{width}_{height}", dirParentName, dirName);

            NewImageWrite.DirrectoryCreate(specificOutputDirectory, newImg, imgName);
        }
    }

    /// <summary>
    /// This class is responsible for Data Augmentation.
    /// </summary>
    internal class DataAugmentation
    {
        private readonly NewImageWrite _newImageWrite = new NewImageWrite();

        /// <summary>
        /// Augments the images specified in the text file at the given path.
        /// </summary>
        /// <param name="path">The path of the text file containing the image paths.</param>
        public void AugmentFactory(string path)
        {
            string path224 = Path.Combine(path, "dataset_size224_224.txt");
            string path299 = Path.Combine(path, "dataset_size299_299.txt");

            Task path224Task = Task.Run(() => AugmentDirectory(path224, "224Task"));
            Task path299Task = Task.Run(() => AugmentDirectory(path299, "299Task"));

            Task.WaitAll(path224Task, path299Task);
        }

        public void AugmentDirectory(string path, string taskName)
        {
            if (taskName == "224Task")
            {
                int totalLines = File.ReadLines(path).Count();
                {
                    using (StreamReader reader = new StreamReader(path))
                    {
                        string line;
                        while ((line = reader.ReadLine()!) != null)
                        {
                            FlipAugmenter(line);
                            RotateAugmenter(line);
                            NoiseAugmenter(line);
                            TranslateAugmenter(line);
                            CopyResizedImage(line);
                        }
                    }
                }
            }
            else if (taskName == "299Task")
            {
                int totalLines = File.ReadLines(path).Count();
                {
                    using (StreamReader reader = new StreamReader(path))
                    {
                        string line;
                        while ((line = reader.ReadLine()!) != null)
                        {
                            FlipAugmenter(line);
                            RotateAugmenter(line);
                            NoiseAugmenter(line);
                            TranslateAugmenter(line);
                            CopyResizedImage(line);
                        }
                    }
                }
            }
            else
            {
                throw new ArgumentOutOfRangeException($"The task '{taskName}' does not exist.");
            }
        }

        /// <summary>
        /// Augments an image by flipping it.
        /// </summary>
        /// <param name="path">The path of the image to augment.</param>
        private void FlipAugmenter(string path)
        {
            string action = "flipped";
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);
            Mat flippedImage = new Mat();
            CvInvoke.Flip(image, flippedImage, FlipType.Both);

            ImageWriterAssistance(path, flippedImage, action);
        }

        /// <summary>
        /// Augments an image by rotating it.
        /// </summary>
        /// <param name="path">The path of the image to augment.</param>
        private void RotateAugmenter(string path)
        {
            string action = "rotated";
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);
            Mat rotatedImage = new Mat();
            CvInvoke.Rotate(image, rotatedImage, RotateFlags.Rotate90Clockwise);

            ImageWriterAssistance(path, rotatedImage, action);
        }

        /// <summary>
        /// Augments an image by adding noise to it.
        /// </summary>
        /// <param name="path">The path of the image to augment.</param>
        private void NoiseAugmenter(string path)
        {
            string action = "noised";
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);
            Mat noisedImage = new Mat();
            CvInvoke.GaussianBlur(image, noisedImage, new Size(5, 5), 0);

            ImageWriterAssistance(path, noisedImage, action);
        }

        /// <summary>
        /// Augments an image by translating it.
        /// </summary>
        /// <param name="path">The path of the image to augment.</param>
        private void TranslateAugmenter(string path)
        {
            string action = "translated";
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);
            int imageWidth = image.Width;
            int imageHeight = image.Height;
            Mat translatedImage = new Mat();
            Matrix<float> shiftMatrix = new Matrix<float>(2, 3);
            Random rand = new Random();
            int shiftX = rand.Next(-50, 50);  // Random shift in x direction between -50 and 50
            int shiftY = rand.Next(-50, 50);  // Random shift in y direction between -50 and 50

            shiftMatrix[0, 0] = 1;  // Identity element
            shiftMatrix[1, 1] = 1;  // Identity element
            shiftMatrix[0, 2] = shiftX;  // Shift in x direction
            shiftMatrix[1, 2] = shiftY;  // Shift in y direction
            CvInvoke.WarpAffine(image, translatedImage, shiftMatrix, new Size(imageWidth, imageHeight), 0);

            ImageWriterAssistance(path, translatedImage, action);
        }

        /// <summary>
        /// Augments an image by copying it to the output directory.
        /// </summary>
        /// <param name="path"></param>
        private void CopyResizedImage(string path)
        {
            string action = "resized";
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);
            Mat copyResizedImage = image;

            ImageWriterAssistance(path, copyResizedImage, action);
        }

        /// <summary>
        /// The directory to output the augmented images to.
        /// </summary>
        public string OutputDirectory { get; } = "D:\\Project\\AI_ML_DS\\Minor_Project_Ai_Plant_Recognition\\Minor_Project_Ai_Plant_Recognition\\Data\\Dataset(augmented)";

        /// <summary>
        /// Assists in writing the augmented image to the output directory.
        /// </summary>
        /// <param name="path">The path of the original image.</param>
        /// <param name="newImg">The augmented image.</param>
        private void ImageWriterAssistance(string path, Mat newImg, string action)
        {
            DirectoryInfo? directoryParentParentInfo = new DirectoryInfo(path).Parent?.Parent?.Parent;
            DirectoryInfo? dirParentInfo = new DirectoryInfo(path).Parent?.Parent;
            DirectoryInfo? dirInfo = new DirectoryInfo(path).Parent;
            string? dirName = dirInfo?.Name!;
            string? dirParentName = dirParentInfo?.Name!;
            string? dirParentParentName = directoryParentParentInfo?.Name!;
            string imgName = Path.GetFileName(path);
            string specificOutputDirectory = Path.Combine(OutputDirectory, action, dirParentParentName, dirParentName, dirName);

            NewImageWrite.DirrectoryCreate(specificOutputDirectory, newImg, imgName);
        }
    }

    /// <summary>
    /// This class is responsible for removing the background from images.
    /// </summary>
    internal class BckgrndRemover
    {
        private readonly NewImageWrite _newImageWrite = new NewImageWrite();

        /// <summary>
        /// Removes the background from the images specified in the text file at the given path.
        /// </summary>
        /// <param name="path">The path of the text file containing the image paths.</param>
        public void RemoveBackgroundFactory(string path)
        {
            string path224 = Path.Combine(path, "dataset_size224_224.txt");
            string path299 = Path.Combine(path, "dataset_size299_299.txt");

            Task path224Task = Task.Run(() => BackGrndRemoveDirectory(path224, "224Task"));
            Task path299Task = Task.Run(() => BackGrndRemoveDirectory(path299, "299Task"));

            Task.WaitAll(path224Task, path299Task);
            //// Path to the Python DLL
            //Runtime.PythonDLL = @"C:\Users\kumar\AppData\Local\Programs\Python\Python312\python312.dll";
            //// Setting the PYTHONHOME environment variable
            //Environment.SetEnvironmentVariable("PYTHONHOME", @"C:\Users\kumar\AppData\Local\Programs\Python\Python312", EnvironmentVariableTarget.Process);

            //try
            //{
            //    // Initialize the Python Engine
            //    PythonEngine.Initialize();

            //    int totalLines = File.ReadLines(Path.Combine(path, "dataset.txt")).Count();
            //    using (var pbar = new ProgressBar(totalLines, "Removing Background", new ProgressBarOptions { ProgressCharacter = '#' }))
            //    {
            //        using (StreamReader reader = new StreamReader(Path.Combine(path, "dataset.txt")))
            //        {
            //            string line;
            //            while ((line = reader.ReadLine()!) != null)
            //            {
            //                PythonScriptRemoveBackground(line);
            //                pbar.Tick();
            //            }
            //        }
            //    }
            //}
            //catch (Exception e)
            //{
            //    Console.WriteLine($"Failed to remove background: {e.Message}");
            //}
            //finally
            //{
            //    // Shutdown the Python Engine
            //    PythonEngine.Shutdown();
            //}
        }

        private void BackGrndRemoveDirectory(string path, string taskName)
        {
            // Path to the Python DLL
            Runtime.PythonDLL = @"C:\Users\kumar\AppData\Local\Programs\Python\Python312\python312.dll";
            // Setting the PYTHONHOME environment variable
            Environment.SetEnvironmentVariable("PYTHONHOME", @"C:\Users\kumar\AppData\Local\Programs\Python\Python312", EnvironmentVariableTarget.Process);

            try
            {
                PythonEngine.Initialize();

                if (taskName == "224Task")
                {
                    int totalLines = File.ReadLines(path).Count();
                    {
                        using (StreamReader reader = new StreamReader(path))
                        {
                            string line;
                            while ((line = reader.ReadLine()!) != null)
                            {
                                PythonScriptRemoveBackground(line);
                            }
                        }
                    }
                }
                else if (taskName == "299Task")
                {
                    int totalLines = File.ReadLines(path).Count();
                    {
                        using (StreamReader reader = new StreamReader(path))
                        {
                            string line;
                            while ((line = reader.ReadLine()!) != null)
                            {
                                PythonScriptRemoveBackground(line);
                            }
                        }
                    }
                }
                else
                {
                    throw new ArgumentOutOfRangeException($"The task '{taskName}' does not exist.");
                }
            }
            catch (Exception e)
            {
                Console.WriteLine($"Failed to remove background: {e.Message}");
            }
            finally
            {
                // Shutdown the Python Engine
                PythonEngine.Shutdown();
            }
        }

        /// <summary>
        /// Executes a Python script to remove the background from an image.
        /// </summary>
        /// <param name="path">The path of the image to process.</param>
        private void PythonScriptRemoveBackground(string path)
        {
            using (Py.GIL())
            {
                // Get the output path for the processed image
                string outputPath = ImageWriterAssistance(path);

                // Read the Python script
                string pythonScript = System.IO.File.ReadAllText(@"D:\Project\AI_ML_DS\Minor_Project_Ai_Plant_Recognition\Minor_Project_Ai_Plant_Recognition\SorceCode\remove_background.py");
                // Run the Python script
                PythonEngine.RunSimpleString(pythonScript);
                // Call the remove_backgrnd function from the Python script
                dynamic removeBackground = PythonEngine.RunSimpleString($"remove_backgrnd(r'{path}', r'{outputPath}')");
            }
        }

        /// <summary>
        /// The directory to output the images with the background removed to.
        /// </summary>
        public string OutputDirectory { get; } = "D:\\Project\\AI_ML_DS\\Minor_Project_Ai_Plant_Recognition\\Minor_Project_Ai_Plant_Recognition\\Data\\Dataset(background_removed)";

        /// <summary>
        /// Assists in writing the image with the background removed to the output directory.
        /// </summary>
        /// <param name="path">The path of the original image.</param>
        /// <param name="newImg">The image with the background removed.</param>
        private string ImageWriterAssistance(string path)
        {
            DirectoryInfo? dirParentParentParentInfo = new DirectoryInfo(path).Parent?.Parent?.Parent?.Parent;
            DirectoryInfo? dirParentParentInfo = new DirectoryInfo(path).Parent?.Parent?.Parent;
            DirectoryInfo? dirParentInfo = new DirectoryInfo(path).Parent?.Parent;
            DirectoryInfo? dirInfo = new DirectoryInfo(path).Parent;
            string? dirName = dirInfo?.Name!;
            string? dirParentName = dirParentInfo?.Name!;
            string? dirParentParentName = dirParentParentInfo?.Name!;
            string? dirParentParentParentName = dirParentParentParentInfo?.Name!;
            string imgName = Path.GetFileName(path);
            string specificOutputDirectory = Path.Combine(OutputDirectory, dirParentParentParentName, dirParentParentName, dirParentName, dirName);

            return Path.Combine(specificOutputDirectory, imgName);
            // Regular image write is not needed.
            //_newImageWrite.DirrectoryCreate(specificOutputDirectory, newImg, imgName);
        }
    }

    /// <summary>
    /// This class is responsble for normalization of images data.
    /// </summary>
    internal class Normalization
    {
        private readonly NewImageWrite _newImageWrite = new NewImageWrite();

        /// <summary>
        /// Normalizes the images specified in the text file at the given path.
        /// </summary>
        /// <param name="path">The path of the text file containing the image paths.</param>
        public void NormalizationFactor(string path)
        {
            string path224 = Path.Combine(path, "dataset_size224_224.txt");
            string path299 = Path.Combine(path, "dataset_size299_299.txt");

            Task path224Task = Task.Run(() => NormalizeDirectory(path224, "224Task"));
            Task path299Task = Task.Run(() => NormalizeDirectory(path299, "299Task"));

            Task.WaitAll(path224Task, path299Task);
            //int totalLines = File.ReadLines(Path.Combine(path, "dataset.txt")).Count();

            //using (var pbar = new ProgressBar(totalLines, "Resizing", new ProgressBarOptions { ProgressCharacter = '#' }))
            //{
            //    using (StreamReader reader = new StreamReader(Path.Combine(path, "dataset.txt")))
            //    {
            //        string line;
            //        while ((line = reader.ReadLine()!) != null)
            //        {
            //            NormalizeColorWise(line);
            //            pbar.Tick();
            //        }
            //    }
            //}
        }

        private void NormalizeDirectory(string path, string taskName)
        {
            if (taskName == "224Task")
            {
                int totalLines = File.ReadLines(path).Count();
                {
                    using (StreamReader reader = new StreamReader(path))
                    {
                        string line;
                        while ((line = reader.ReadLine()!) != null)
                        {
                            NormalizeColorWise(line);
                        }
                    }
                }
            }
            else if (taskName == "299Task")
            {
                int totalLines = File.ReadLines(path).Count();
                {
                    using (StreamReader reader = new StreamReader(path))
                    {
                        string line;
                        while ((line = reader.ReadLine()!) != null)
                        {
                            NormalizeColorWise(line);
                        }
                    }
                }
            }
            else
            {
                throw new ArgumentOutOfRangeException($"The task '{taskName}' does not exist.");
            }
        }

        /// <summary>
        /// Normalizes an image using min-max.
        /// </summary>
        /// <param name="path">The path of the image to process.</param>
        public void NormalizeColorWise(string path)
        {
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);

            Mat normalizedImage = image.Clone();
            VectorOfMat vm = new VectorOfMat();
            CvInvoke.Split(image, vm);

            for (int i = 0; i < vm.Size; i++)
            {
                Mat channel = vm[i];
                CvInvoke.Normalize(channel, channel, 0, 255, NormType.MinMax);
            }
            CvInvoke.Merge(vm, normalizedImage);

            ImageWriterAssistance(path, normalizedImage);
        }

        /// <summary>
        /// The directory to output the normalized images to the directory.
        /// </summary>
        public string OutputDirectory { get; } = "D:\\Project\\AI_ML_DS\\Minor_Project_Ai_Plant_Recognition\\Minor_Project_Ai_Plant_Recognition\\Data\\Dataset(normalized)";

        /// <summary>
        /// Assists in writing the normalized image to the output directory.
        /// </summary>
        /// <param name="path">The path of the original image.</param>
        /// <param name="newImg">The image with the background removed.</param>

        private void ImageWriterAssistance(string path, Mat newImg)
        {
            DirectoryInfo? dirParentParentParentInfo = new DirectoryInfo(path).Parent?.Parent?.Parent?.Parent;
            DirectoryInfo? dirParentParentInfo = new DirectoryInfo(path).Parent?.Parent?.Parent;
            DirectoryInfo? dirParentInfo = new DirectoryInfo(path).Parent?.Parent;
            DirectoryInfo? dirInfo = new DirectoryInfo(path).Parent;
            string? dirName = dirInfo?.Name!;
            string? dirParentName = dirParentInfo?.Name!;
            string? dirParentParentName = dirParentParentInfo?.Name!;
            string? dirParentParentParentName = dirParentParentParentInfo?.Name!;
            string imgName = Path.GetFileName(path);
            string specificOutputDirectory = Path.Combine(OutputDirectory, dirParentParentParentName, dirParentParentName, dirParentName, dirName);

            NewImageWrite.DirrectoryCreate(specificOutputDirectory, newImg, imgName);
        }
    }
}ØOriginalContent¿™SelectionsëÉ•Caret¿•StartÕR‡£EndÕg"®FilePathŸxD:\Project\AI_ML_DS\Minor_Project_Ai_Plant_Recognition\Minor_Project_Ai_Plant_Recognition\SorceCode\DataPreprocessing.cs®Language¢C#ëíìÅ•Value ŸEcan you please check complete selected code and then give me solution¿®ResponseÖßContent⁄√The error at `PythonEngine.Initialize()` is likely due to the Python engine being initialized multiple times in different threads. The Python engine should be initialized only once, and each thread should have its own Python environment.

To fix this, you can use `PythonEngine.BeginAllowThreads()` to get a Python thread state that you can use to initialize the Python engine in each thread. Here's how you can modify your code:

```csharp
public void RemoveBackgroundFactory(string path)
{
    string path224 = Path.Combine(path, "dataset_size224_224.txt");
    string path299 = Path.Combine(path, "dataset_size299_299.txt");

    // Initialize the Python engine
    if (!PythonEngine.IsInitialized)
    {
        PythonEngine.Initialize();
    }

    // Get a Python thread state
    var pyThreadState = PythonEngine.BeginAllowThreads();

    Task path224Task = Task.Run(() =>
    {
        // Use the Python thread state in this thread
        PythonEngine.BeginThread(pyThreadState);
        BackGrndRemoveDirectory(path224, "224Task");
        PythonEngine.EndThread();
    });

    Task path299Task = Task.Run(() =>
    {
        // Use the Python thread state in this thread
        PythonEngine.BeginThread(pyThreadState);
        BackGrndRemoveDirectory(path299, "299Task");
        PythonEngine.EndThread();
    });

    Task.WaitAll(path224Task, path299Task);

    // End the use of the Python thread state
    PythonEngine.EndAllowThreads(pyThreadState);
}
```

This code initializes the Python engine once and gets a Python thread state using `PythonEngine.BeginAllowThreads()`. Then, it uses this thread state to initialize the Python engine in each thread. After the tasks are done, it ends the use of the Python thread state with `PythonEngine.EndAllowThreads(pyThreadState)`.

Please note that this code assumes that `BackGrndRemoveDirectory` and any other methods it calls are thread-safe. If they're not, you'll need to add synchronization to prevent race conditions.

Also, please note that you should remove the `PythonEngine.Initialize();` and `PythonEngine.Shutdown();` calls from the `BackGrndRemoveDirectory` method, as the Python engine is now being initialized and shut down in the `RemoveBackgroundFactory` method.§Type ¶StatusØFollowUpPromptsíŸ7How can I ensure that my methods are thread-safe in C#?ŸBCan you explain more about Python's Global Interpreter Lock (GIL)?≥CodeVulnerabilitiesê∂LoggedSkillInvocations¿Ü®DateTime◊ˇd7¢0f(ªœ™ThreadName¿∞CopilotSessionIdÇ§GuidŸ$64b71c8f-ffb9-409f-957d-1086d9b01afb®ClientIdÅ¢IdŸ4Microsoft.VisualStudio.Conversations.Chat.HelpWindowßRequestÅßRequestïŸ$1b9f98a6-d92d-46fb-8fc5-e2f52e76a09bŸ$e840252e-f212-4d9e-bf58-a992fedea42fëÜØProviderMonikerÇ§NameŸ6Microsoft.VisualStudio.Copilot.DocumentContextProviderßVersion£0.1¶Member§file©CanReduce√©RequestIdŸ$1b9f98a6-d92d-46fb-8fc5-e2f52e76a09b©Reference¿•Value»Ö˘dŸëMicrosoft.VisualStudio.Copilot.DocumentContext, Microsoft.VisualStudio.Copilot, Version=0.2.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3aÖßContent⁄Ññusing Emgu.CV;
using Emgu.CV.CvEnum;
using Emgu.CV.Util;
using Python.Runtime;
using System.Drawing;

namespace Minor_Project_Ai_Plant_Recognition.SorceCode.Preprocessing
{
    /// <summary>
    /// This class is responsible for parsing images from the given directory path.
    /// It writes the paths of the images to a text file.
    /// </summary>
    internal class ImageAccess
    {
        /// <summary>
        /// Parses the directories for image files and writes their paths to a text file.
        /// </summary>
        /// <param name="path">The base path of the directories.</param>
        /// <param name="pathTextFile">The path of the text file to write to.</param>
        public void DirectoryParser(string path, string pathTextFile, string action)
        {
            string[] directories;
            List<string> directoriesList = pathMakerBasedOnAction(path, action);
            directories = directoriesList.ToArray();

            Directory.CreateDirectory(pathTextFile);

            if (action == "Augment" || action == "BckgrndRemove" || action == "Normalization")
            {
                DirParserByImgDim(directories, pathTextFile);
            }
            else if (action == "Resize" || action == "parse")
            {
                DirParserByClass(directories, pathTextFile);
            }
            else
            {
                throw new ArgumentOutOfRangeException($"The action '{action}' does not exist.");
            }
        }

        public void DirParserByClass(string[] directories, string pathTextFile)
        {
            if (File.Exists(Path.Combine(pathTextFile, "dataset_base.txt")))
            {
                File.Delete(Path.Combine(pathTextFile, "dataset_base.txt"));
            }
            using (StreamWriter writer = new(Path.Combine(pathTextFile, "dataset_base.txt"), true))
            {
                foreach (string directory in directories)
                {
                    if (!Directory.Exists(directory))
                    {
                        throw new DirectoryNotFoundException($"The directory '{directory}' does not exist.");
                    }

                    foreach (string subdirectory in Directory.EnumerateDirectories(directory))
                    {
                        foreach (string filePath in Directory.EnumerateFiles(subdirectory))
                        {
                            string extension = Path.GetExtension(filePath);
                            if (extension == ".jpg" || extension == ".png")
                            {
                                writer.WriteLine(filePath);
                            }
                        }
                    }
                }
            }
        }

        public void DirParserByImgDim(string[] directories, string pathTextFile)
        {
            //using (StreamWriter writer = new(Path.Combine(pathTextFile, $"dataset_.{parentName}txt"), false))
            if (File.Exists(Path.Combine(pathTextFile, $"dataset_size224_224.txt")))
            {
                File.Delete(Path.Combine(pathTextFile, $"dataset_size224_224.txt"));
            }
            if (File.Exists(Path.Combine(pathTextFile, $"dataset_size299_299.txt")))
            {
                File.Delete(Path.Combine(pathTextFile, $"dataset_size299_299.txt"));
            }

            foreach (string directory in directories)
            {
                if (new DirectoryInfo(directory).Parent!.Name == "size224_224")
                {
                    if (!Directory.Exists(directory))
                    {
                        throw new DirectoryNotFoundException($"The directory '{directory}' does not exist.");
                    }
                    using (StreamWriter writer = new(Path.Combine(pathTextFile, $"dataset_size224_224.txt"), true))
                    {
                        foreach (string subdirectory in Directory.EnumerateDirectories(directory))
                        {
                            foreach (string filePath in Directory.EnumerateFiles(subdirectory))
                            {
                                string extension = Path.GetExtension(filePath);
                                if (extension == ".jpg" || extension == ".png")
                                {
                                    writer.WriteLine(filePath);
                                }
                            }
                        }
                    }
                }
                else if (new DirectoryInfo(directory).Parent!.Name == "size299_299")
                {
                    if (!Directory.Exists(directory))
                    {
                        throw new DirectoryNotFoundException($"The directory '{directory}' does not exist.");
                    }
                    using (StreamWriter writer = new(Path.Combine(pathTextFile, $"dataset_size299_299.txt"), true))
                    {
                        foreach (string subdirectory in Directory.EnumerateDirectories(directory))
                        {
                            foreach (string filePath in Directory.EnumerateFiles(subdirectory))
                            {
                                string extension = Path.GetExtension(filePath);
                                if (extension == ".jpg" || extension == ".png")
                                {
                                    writer.WriteLine(filePath);
                                }
                            }
                        }
                    }
                }
                else
                {
                    throw new DirectoryNotFoundException($"The directory does not exist.");
                }
            }
        }

        /// <summary>
        /// Constructs a list of directories based on the specified action.
        /// </summary>
        /// <param name="path">The base path to use when constructing the directories.</param>
        /// <param name="action">The action to base the directories on. Can be "resize", "parse", or "Augment".</param>
        /// <returns>A list of directories constructed based on the specified action.</returns>
        public List<string> pathMakerBasedOnAction(string path, string action)
        {
            List<string> directories = new List<string>();
            List<string> tempDir = new List<string>();

            if (action == "Resize" || action == "parse")
            {
                directories.Add(Path.Combine(path, "Medicinal_Leaf_dataset"));
                directories.Add(Path.Combine(path, "Medicinal_plant_dataset"));
            }
            else if (action == "Augment")
            {
                tempDir.Add(Path.Combine(path, "size224_224"));
                tempDir.Add(Path.Combine(path, "size299_299"));

                foreach (string dir in tempDir.ToList()) // Use ToList to create a copy for iteration
                {
                    directories.AddRange(pathMakerBasedOnAction(dir, "parse"));
                }
            }
            else if (action == "BckgrndRemove")
            {
                List<string> dirNames = new List<string> { "flipped", "noised", "resized", "rotated", "translated" };
                List<string> dimension = new List<string> { "size224_224", "size299_299" };
                foreach (string dirName in dirNames)
                {
                    foreach (string dim in dimension)
                    {
                        tempDir.Add(Path.Combine(path, dirName, dim));
                    }
                }

                foreach (string dir in tempDir.ToList()) // Use ToList to create a copy for iteration
                {
                    directories.AddRange(pathMakerBasedOnAction(dir, "parse"));
                }
            }
            else if (action == "Normalization")
            {
                List<string> dirNames = new List<string> { "flipped", "noised", "resized", "rotated", "translated" };
                List<string> dimension = new List<string> { "size224_224", "size299_299" };
                foreach (string dirName in dirNames)
                {
                    foreach (string dim in dimension)
                    {
                        tempDir.Add(Path.Combine(path, dirName, dim));
                    }
                }

                foreach (string dir in tempDir.ToList()) // Use ToList to create a copy for iteration
                {
                    directories.AddRange(pathMakerBasedOnAction(dir, "parse"));
                }
            }
            return directories;
        }
    }

    /// <summary>
    /// This class is responsible for writing images to a directory.
    /// </summary>
    internal class NewImageWrite
    {
        /// <summary>
        /// Creates a directory and writes an image to it.
        /// </summary>
        /// <param name="path">The path of the directory to create.</param>
        /// <param name="newImg">The image to write.</param>
        /// <param name="imgName">The name of the image file.</param>
        public static void DirrectoryCreate(string path, Mat newImg, string imgName)
        {
            if (!Directory.Exists(path))
            {
                try
                {
                    Directory.CreateDirectory(path);
                }
                catch (Exception e)
                {
                    Console.WriteLine($"Failed to create directory: {e}");
                }
            }

            WriteImage(path, newImg, imgName);
        }

        /// <summary>
        /// Writes an image to a file.
        /// </summary>
        /// <param name="path">The path of the file to write to.</param>
        /// <param name="newImg">The image to write.</param>
        /// <param name="imgName">The name of the image file.</param>
        private static void WriteImage(string path, Mat newImg, string imgName)
        {
            string newPath = Path.Combine(path, imgName);

            try
            {
                CvInvoke.Imwrite(newPath, newImg);
            }
            catch (IOException e)
            {
                Console.WriteLine("In NewImageWriter");
                Console.WriteLine($"Failed to write image: {e}");
            }
        }
    }

    /// <summary>
    /// This class is responsible for resizing images.
    /// </summary>
    internal class ImageResize
    {
        /// <summary>
        /// The directory to output the resized images to.
        /// </summary>
        public string OutputDirectory { get; } = "D:\\Project\\AI_ML_DS\\Minor_Project_Ai_Plant_Recognition\\Minor_Project_Ai_Plant_Recognition\\Data\\Dataset(resized)";

        private readonly NewImageWrite _newImageWrite = new NewImageWrite();

        /// <summary>
        /// Resizes the images specified in the text file at the given path.
        /// </summary>
        /// <param name="path">The path of the text file containing the image paths.</param>
        public void ResizeFactory(string path)
        {
            string textPath = Path.Combine(path, "dataset_base.txt");

            ResizeDirectory(textPath, 224, 224);
            ResizeDirectory(textPath, 299, 299);
        }

        public void ResizeDirectory(string path, int width, int height)
        {
            var lines = File.ReadLines(path);
            Parallel.ForEach(lines, (line) =>
            {
                Resizer(line, width, height);
            });
        }

        /// <summary>
        /// Resizes an image to the specified width and height.
        /// </summary>
        /// <param name="path">The path of the image to resize.</param>
        /// <param name="width">The width to resize to.</param>
        /// <param name="height">The height to resize to.</param>
        private void Resizer(string path, int width, int height)
        {
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);
            Mat resizedImage = new Mat();
            CvInvoke.Resize(image, resizedImage, new Size(width, height), 0, 0, Inter.Area);

            ImageWriterAssistance(path, resizedImage, width, height);
        }

        /// <summary>
        /// Assists in writing the resized image to the output directory.
        /// </summary>
        /// <param name="path">The path of the original image.</param>
        /// <param name="newImg">The resized image.</param>
        /// <param name="width">The width of the resized image.</param>
        /// <param name="height">The height of the resized image.</param>
        private void ImageWriterAssistance(string path, Mat newImg, int width, int height)
        {
            DirectoryInfo? dirParentInfo = new DirectoryInfo(path).Parent?.Parent;
            DirectoryInfo? dirInfo = new DirectoryInfo(path).Parent;
            string? dirName = dirInfo?.Name!;
            string? dirParentName = dirParentInfo?.Name!;
            string imgName = Path.GetFileName(path);
            string specificOutputDirectory = Path.Combine(OutputDirectory, $"size{width}_{height}", dirParentName, dirName);

            NewImageWrite.DirrectoryCreate(specificOutputDirectory, newImg, imgName);
        }
    }

    /// <summary>
    /// This class is responsible for Data Augmentation.
    /// </summary>
    internal class DataAugmentation
    {
        private readonly NewImageWrite _newImageWrite = new NewImageWrite();

        /// <summary>
        /// Augments the images specified in the text file at the given path.
        /// </summary>
        /// <param name="path">The path of the text file containing the image paths.</param>
        public void AugmentFactory(string path)
        {
            string path224 = Path.Combine(path, "dataset_size224_224.txt");
            string path299 = Path.Combine(path, "dataset_size299_299.txt");

            Task path224Task = Task.Run(() => AugmentDirectory(path224, "224Task"));
            Task path299Task = Task.Run(() => AugmentDirectory(path299, "299Task"));

            Task.WaitAll(path224Task, path299Task);
        }

        public void AugmentDirectory(string path, string taskName)
        {
            if (taskName == "224Task")
            {
                int totalLines = File.ReadLines(path).Count();
                {
                    using (StreamReader reader = new StreamReader(path))
                    {
                        string line;
                        while ((line = reader.ReadLine()!) != null)
                        {
                            FlipAugmenter(line);
                            RotateAugmenter(line);
                            NoiseAugmenter(line);
                            TranslateAugmenter(line);
                            CopyResizedImage(line);
                        }
                    }
                }
            }
            else if (taskName == "299Task")
            {
                int totalLines = File.ReadLines(path).Count();
                {
                    using (StreamReader reader = new StreamReader(path))
                    {
                        string line;
                        while ((line = reader.ReadLine()!) != null)
                        {
                            FlipAugmenter(line);
                            RotateAugmenter(line);
                            NoiseAugmenter(line);
                            TranslateAugmenter(line);
                            CopyResizedImage(line);
                        }
                    }
                }
            }
            else
            {
                throw new ArgumentOutOfRangeException($"The task '{taskName}' does not exist.");
            }
        }

        /// <summary>
        /// Augments an image by flipping it.
        /// </summary>
        /// <param name="path">The path of the image to augment.</param>
        private void FlipAugmenter(string path)
        {
            string action = "flipped";
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);
            Mat flippedImage = new Mat();
            CvInvoke.Flip(image, flippedImage, FlipType.Both);

            ImageWriterAssistance(path, flippedImage, action);
        }

        /// <summary>
        /// Augments an image by rotating it.
        /// </summary>
        /// <param name="path">The path of the image to augment.</param>
        private void RotateAugmenter(string path)
        {
            string action = "rotated";
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);
            Mat rotatedImage = new Mat();
            CvInvoke.Rotate(image, rotatedImage, RotateFlags.Rotate90Clockwise);

            ImageWriterAssistance(path, rotatedImage, action);
        }

        /// <summary>
        /// Augments an image by adding noise to it.
        /// </summary>
        /// <param name="path">The path of the image to augment.</param>
        private void NoiseAugmenter(string path)
        {
            string action = "noised";
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);
            Mat noisedImage = new Mat();
            CvInvoke.GaussianBlur(image, noisedImage, new Size(5, 5), 0);

            ImageWriterAssistance(path, noisedImage, action);
        }

        /// <summary>
        /// Augments an image by translating it.
        /// </summary>
        /// <param name="path">The path of the image to augment.</param>
        private void TranslateAugmenter(string path)
        {
            string action = "translated";
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);
            int imageWidth = image.Width;
            int imageHeight = image.Height;
            Mat translatedImage = new Mat();
            Matrix<float> shiftMatrix = new Matrix<float>(2, 3);
            Random rand = new Random();
            int shiftX = rand.Next(-50, 50);  // Random shift in x direction between -50 and 50
            int shiftY = rand.Next(-50, 50);  // Random shift in y direction between -50 and 50

            shiftMatrix[0, 0] = 1;  // Identity element
            shiftMatrix[1, 1] = 1;  // Identity element
            shiftMatrix[0, 2] = shiftX;  // Shift in x direction
            shiftMatrix[1, 2] = shiftY;  // Shift in y direction
            CvInvoke.WarpAffine(image, translatedImage, shiftMatrix, new Size(imageWidth, imageHeight), 0);

            ImageWriterAssistance(path, translatedImage, action);
        }

        /// <summary>
        /// Augments an image by copying it to the output directory.
        /// </summary>
        /// <param name="path"></param>
        private void CopyResizedImage(string path)
        {
            string action = "resized";
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);
            Mat copyResizedImage = image;

            ImageWriterAssistance(path, copyResizedImage, action);
        }

        /// <summary>
        /// The directory to output the augmented images to.
        /// </summary>
        public string OutputDirectory { get; } = "D:\\Project\\AI_ML_DS\\Minor_Project_Ai_Plant_Recognition\\Minor_Project_Ai_Plant_Recognition\\Data\\Dataset(augmented)";

        /// <summary>
        /// Assists in writing the augmented image to the output directory.
        /// </summary>
        /// <param name="path">The path of the original image.</param>
        /// <param name="newImg">The augmented image.</param>
        private void ImageWriterAssistance(string path, Mat newImg, string action)
        {
            DirectoryInfo? directoryParentParentInfo = new DirectoryInfo(path).Parent?.Parent?.Parent;
            DirectoryInfo? dirParentInfo = new DirectoryInfo(path).Parent?.Parent;
            DirectoryInfo? dirInfo = new DirectoryInfo(path).Parent;
            string? dirName = dirInfo?.Name!;
            string? dirParentName = dirParentInfo?.Name!;
            string? dirParentParentName = directoryParentParentInfo?.Name!;
            string imgName = Path.GetFileName(path);
            string specificOutputDirectory = Path.Combine(OutputDirectory, action, dirParentParentName, dirParentName, dirName);

            NewImageWrite.DirrectoryCreate(specificOutputDirectory, newImg, imgName);
        }
    }

    /// <summary>
    /// This class is responsible for removing the background from images.
    /// </summary>
    internal class BckgrndRemover
    {
        private readonly NewImageWrite _newImageWrite = new NewImageWrite();

        /// <summary>
        /// Removes the background from the images specified in the text file at the given path.
        /// </summary>
        /// <param name="path">The path of the text file containing the image paths.</param>
        public void RemoveBackgroundFactory(string path)
        {
            string path224 = Path.Combine(path, "dataset_size224_224.txt");
            string path299 = Path.Combine(path, "dataset_size299_299.txt");

            try
            {
                if (!PythonEngine.IsInitialized)
                {
                    PythonEngine.Initialize();
                }

                var pyThreadState = PythonEngine.BeginAllowThreads();

                Task task224 = Task.Run(() => BackGrndRemoveDirectory(path224, "224Task"));
                Task task299 = Task.Run(() => BackGrndRemoveDirectory(path299, "299Task"));

                Task.WaitAll(task224, task299);

                PythonEngine.EndAllowThreads(pyThreadState);
            }
            catch (Exception e)
            {
                WriteLine($"Failed to remove background: {e.Message}");
            }
            finally
            {
                PythonEngine.Shutdown();
            }
            

            //Task path224Task = Task.Run(() => BackGrndRemoveDirectory(path224, "224Task"));
            //Task path299Task = Task.Run(() => BackGrndRemoveDirectory(path299, "299Task"));

            //Task.WaitAll(path224Task, path299Task);
            //// Path to the Python DLL
            //Runtime.PythonDLL = @"C:\Users\kumar\AppData\Local\Programs\Python\Python312\python312.dll";
            //// Setting the PYTHONHOME environment variable
            //Environment.SetEnvironmentVariable("PYTHONHOME", @"C:\Users\kumar\AppData\Local\Programs\Python\Python312", EnvironmentVariableTarget.Process);

            //try
            //{
            //    // Initialize the Python Engine
            //    PythonEngine.Initialize();

            //    int totalLines = File.ReadLines(Path.Combine(path, "dataset.txt")).Count();
            //    using (var pbar = new ProgressBar(totalLines, "Removing Background", new ProgressBarOptions { ProgressCharacter = '#' }))
            //    {
            //        using (StreamReader reader = new StreamReader(Path.Combine(path, "dataset.txt")))
            //        {
            //            string line;
            //            while ((line = reader.ReadLine()!) != null)
            //            {
            //                PythonScriptRemoveBackground(line);
            //                pbar.Tick();
            //            }
            //        }
            //    }
            //}
            //catch (Exception e)
            //{
            //    Console.WriteLine($"Failed to remove background: {e.Message}");
            //}
            //finally
            //{
            //    // Shutdown the Python Engine
            //    PythonEngine.Shutdown();
            //}
        }

        private void BackGrndRemoveDirectory(string path, string taskName)
        {
            // Path to the Python DLL
            Runtime.PythonDLL = @"C:\Users\kumar\AppData\Local\Programs\Python\Python312\python312.dll";
            // Setting the PYTHONHOME environment variable
            Environment.SetEnvironmentVariable("PYTHONHOME", @"C:\Users\kumar\AppData\Local\Programs\Python\Python312", EnvironmentVariableTarget.Process);

            try
            {

                if (taskName == "224Task")
                {
                    int totalLines = File.ReadLines(path).Count();
                    {
                        using (StreamReader reader = new StreamReader(path))
                        {
                            string line;
                            while ((line = reader.ReadLine()!) != null)
                            {
                                PythonScriptRemoveBackground(line);
                            }
                        }
                    }
                }
                else if (taskName == "299Task")
                {
                    int totalLines = File.ReadLines(path).Count();
                    {
                        using (StreamReader reader = new StreamReader(path))
                        {
                            string line;
                            while ((line = reader.ReadLine()!) != null)
                            {
                                PythonScriptRemoveBackground(line);
                            }
                        }
                    }
                }
                else
                {
                    throw new ArgumentOutOfRangeException($"The task '{taskName}' does not exist.");
                }
            }
            catch (Exception e)
            {
                Console.WriteLine($"Failed to remove background: {e.Message}");
            }
        }

        /// <summary>
        /// Executes a Python script to remove the background from an image.
        /// </summary>
        /// <param name="path">The path of the image to process.</param>
        private void PythonScriptRemoveBackground(string path)
        {
            using (Py.GIL())
            {
                // Get the output path for the processed image
                string outputPath = ImageWriterAssistance(path);

                // Read the Python script
                string pythonScript = System.IO.File.ReadAllText(@"D:\Project\AI_ML_DS\Minor_Project_Ai_Plant_Recognition\Minor_Project_Ai_Plant_Recognition\SorceCode\remove_background.py");
                // Run the Python script
                PythonEngine.RunSimpleString(pythonScript);
                // Call the remove_backgrnd function from the Python script
                dynamic removeBackground = PythonEngine.RunSimpleString($"remove_backgrnd(r'{path}', r'{outputPath}')");
            }
        }

        /// <summary>
        /// The directory to output the images with the background removed to.
        /// </summary>
        public string OutputDirectory { get; } = "D:\\Project\\AI_ML_DS\\Minor_Project_Ai_Plant_Recognition\\Minor_Project_Ai_Plant_Recognition\\Data\\Dataset(background_removed)";

        /// <summary>
        /// Assists in writing the image with the background removed to the output directory.
        /// </summary>
        /// <param name="path">The path of the original image.</param>
        /// <param name="newImg">The image with the background removed.</param>
        private string ImageWriterAssistance(string path)
        {
            DirectoryInfo? dirParentParentParentInfo = new DirectoryInfo(path).Parent?.Parent?.Parent?.Parent;
            DirectoryInfo? dirParentParentInfo = new DirectoryInfo(path).Parent?.Parent?.Parent;
            DirectoryInfo? dirParentInfo = new DirectoryInfo(path).Parent?.Parent;
            DirectoryInfo? dirInfo = new DirectoryInfo(path).Parent;
            string? dirName = dirInfo?.Name!;
            string? dirParentName = dirParentInfo?.Name!;
            string? dirParentParentName = dirParentParentInfo?.Name!;
            string? dirParentParentParentName = dirParentParentParentInfo?.Name!;
            string imgName = Path.GetFileName(path);
            string specificOutputDirectory = Path.Combine(OutputDirectory, dirParentParentParentName, dirParentParentName, dirParentName, dirName);

            return Path.Combine(specificOutputDirectory, imgName);
            // Regular image write is not needed.
            //_newImageWrite.DirrectoryCreate(specificOutputDirectory, newImg, imgName);
        }
    }

    /// <summary>
    /// This class is responsble for normalization of images data.
    /// </summary>
    internal class Normalization
    {
        private readonly NewImageWrite _newImageWrite = new NewImageWrite();

        /// <summary>
        /// Normalizes the images specified in the text file at the given path.
        /// </summary>
        /// <param name="path">The path of the text file containing the image paths.</param>
        public void NormalizationFactor(string path)
        {
            string path224 = Path.Combine(path, "dataset_size224_224.txt");
            string path299 = Path.Combine(path, "dataset_size299_299.txt");

            Task path224Task = Task.Run(() => NormalizeDirectory(path224, "224Task"));
            Task path299Task = Task.Run(() => NormalizeDirectory(path299, "299Task"));

            Task.WaitAll(path224Task, path299Task);
            //int totalLines = File.ReadLines(Path.Combine(path, "dataset.txt")).Count();

            //using (var pbar = new ProgressBar(totalLines, "Resizing", new ProgressBarOptions { ProgressCharacter = '#' }))
            //{
            //    using (StreamReader reader = new StreamReader(Path.Combine(path, "dataset.txt")))
            //    {
            //        string line;
            //        while ((line = reader.ReadLine()!) != null)
            //        {
            //            NormalizeColorWise(line);
            //            pbar.Tick();
            //        }
            //    }
            //}
        }

        private void NormalizeDirectory(string path, string taskName)
        {
            if (taskName == "224Task")
            {
                int totalLines = File.ReadLines(path).Count();
                {
                    using (StreamReader reader = new StreamReader(path))
                    {
                        string line;
                        while ((line = reader.ReadLine()!) != null)
                        {
                            NormalizeColorWise(line);
                        }
                    }
                }
            }
            else if (taskName == "299Task")
            {
                int totalLines = File.ReadLines(path).Count();
                {
                    using (StreamReader reader = new StreamReader(path))
                    {
                        string line;
                        while ((line = reader.ReadLine()!) != null)
                        {
                            NormalizeColorWise(line);
                        }
                    }
                }
            }
            else
            {
                throw new ArgumentOutOfRangeException($"The task '{taskName}' does not exist.");
            }
        }

        /// <summary>
        /// Normalizes an image using min-max.
        /// </summary>
        /// <param name="path">The path of the image to process.</param>
        public void NormalizeColorWise(string path)
        {
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);

            Mat normalizedImage = image.Clone();
            VectorOfMat vm = new VectorOfMat();
            CvInvoke.Split(image, vm);

            for (int i = 0; i < vm.Size; i++)
            {
                Mat channel = vm[i];
                CvInvoke.Normalize(channel, channel, 0, 255, NormType.MinMax);
            }
            CvInvoke.Merge(vm, normalizedImage);

            ImageWriterAssistance(path, normalizedImage);
        }

        /// <summary>
        /// The directory to output the normalized images to the directory.
        /// </summary>
        public string OutputDirectory { get; } = "D:\\Project\\AI_ML_DS\\Minor_Project_Ai_Plant_Recognition\\Minor_Project_Ai_Plant_Recognition\\Data\\Dataset(normalized)";

        /// <summary>
        /// Assists in writing the normalized image to the output directory.
        /// </summary>
        /// <param name="path">The path of the original image.</param>
        /// <param name="newImg">The image with the background removed.</param>

        private void ImageWriterAssistance(string path, Mat newImg)
        {
            DirectoryInfo? dirParentParentParentInfo = new DirectoryInfo(path).Parent?.Parent?.Parent?.Parent;
            DirectoryInfo? dirParentParentInfo = new DirectoryInfo(path).Parent?.Parent?.Parent;
            DirectoryInfo? dirParentInfo = new DirectoryInfo(path).Parent?.Parent;
            DirectoryInfo? dirInfo = new DirectoryInfo(path).Parent;
            string? dirName = dirInfo?.Name!;
            string? dirParentName = dirParentInfo?.Name!;
            string? dirParentParentName = dirParentParentInfo?.Name!;
            string? dirParentParentParentName = dirParentParentParentInfo?.Name!;
            string imgName = Path.GetFileName(path);
            string specificOutputDirectory = Path.Combine(OutputDirectory, dirParentParentParentName, dirParentParentName, dirParentName, dirName);

            NewImageWrite.DirrectoryCreate(specificOutputDirectory, newImg, imgName);
        }
    }
}ØOriginalContent¿™SelectionsëÉ•Caret¿•StartÕQ°£EndÕpZ®FilePathŸxD:\Project\AI_ML_DS\Minor_Project_Ai_Plant_Recognition\Minor_Project_Ai_Plant_Recognition\SorceCode\DataPreprocessing.cs®Language¢C#ëíìÅ•Value ±is it correct now¿®ResponseÖßContent⁄	•The code you've provided seems to be correct in terms of PythonEngine initialization and shutdown. You're initializing the PythonEngine once in the `RemoveBackgroundFactory` method and shutting it down in the same method, which is the correct approach. 

However, there are a few things to note:

1. You're setting the Python DLL path and the PYTHONHOME environment variable in the `BackGrndRemoveDirectory` method. These should be set before the PythonEngine is initialized, so they should be moved to the `RemoveBackgroundFactory` method.

2. The `PythonEngine.BeginAllowThreads()` and `PythonEngine.EndAllowThreads(pyThreadState)` calls are not necessary in this case, because you're not using Python objects across different threads. You can remove these calls.

3. The `BackGrndRemoveDirectory` method is being run on different threads, but it's not clear if this method and the methods it calls are thread-safe. If they're not, you'll need to add synchronization to prevent race conditions.

4. The `PythonScriptRemoveBackground` method is being called from different threads, but it's not clear if this method is thread-safe. If it's not, you'll need to add synchronization to prevent race conditions.

5. The `PythonScriptRemoveBackground` method is running a Python script and calling a function from that script. If the script or function have any side effects (like modifying global variables), this could cause issues when the method is called from different threads.

6. The `PythonScriptRemoveBackground` method is using `PythonEngine.RunSimpleString` to run the Python script and call the function. This is fine for simple scripts, but for more complex scripts, you might want to use `PythonEngine.Exec` or `PythonEngine.RunString` instead, as these methods provide more control and better error handling.

7. The `PythonScriptRemoveBackground` method is not handling any errors that might occur when running the Python script or calling the function. You might want to add error handling to this method to make it more robust.

8. The `PythonScriptRemoveBackground` method is not checking if the Python script file exists before trying to read it. You might want to add a check for this to prevent a `FileNotFoundException` from being thrown.

9. The `PythonScriptRemoveBackground` method is not checking if the image file exists before trying to process it. You might want to add a check for this to prevent a `FileNotFoundException` from being thrown.§Type ¶StatusØFollowUpPromptsíŸ=How can I add synchronization to make my methods thread-safe?ŸuCan you show me how to use `PythonEngine.Exec` or `PythonEngine.RunString` instead of `PythonEngine.RunSimpleString`?≥CodeVulnerabilitiesê∂LoggedSkillInvocations¿Ü®DateTime◊ˇc	ä@f(æØ™ThreadName¿∞CopilotSessionIdÇ§GuidŸ$64b71c8f-ffb9-409f-957d-1086d9b01afb®ClientIdÅ¢IdŸ4Microsoft.VisualStudio.Conversations.Chat.HelpWindowßRequestÅßRequestïŸ$b7f3f0d4-6ca0-440c-ad0e-5c314f674877Ÿ$b587a859-1395-4e8b-ad86-a7a7ea38665aëÜØProviderMonikerÇ§NameŸ6Microsoft.VisualStudio.Copilot.DocumentContextProviderßVersion£0.1¶Member§file©CanReduce√©RequestIdŸ$b7f3f0d4-6ca0-440c-ad0e-5c314f674877©Reference¿•Value»Ö–dŸëMicrosoft.VisualStudio.Copilot.DocumentContext, Microsoft.VisualStudio.Copilot, Version=0.2.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3aÖßContent⁄Ñmusing Emgu.CV;
using Emgu.CV.CvEnum;
using Emgu.CV.Util;
using Python.Runtime;
using System.Drawing;

namespace Minor_Project_Ai_Plant_Recognition.SorceCode.Preprocessing
{
    /// <summary>
    /// This class is responsible for parsing images from the given directory path.
    /// It writes the paths of the images to a text file.
    /// </summary>
    internal class ImageAccess
    {
        /// <summary>
        /// Parses the directories for image files and writes their paths to a text file.
        /// </summary>
        /// <param name="path">The base path of the directories.</param>
        /// <param name="pathTextFile">The path of the text file to write to.</param>
        public void DirectoryParser(string path, string pathTextFile, string action)
        {
            string[] directories;
            List<string> directoriesList = pathMakerBasedOnAction(path, action);
            directories = directoriesList.ToArray();

            Directory.CreateDirectory(pathTextFile);

            if (action == "Augment" || action == "BckgrndRemove" || action == "Normalization")
            {
                DirParserByImgDim(directories, pathTextFile);
            }
            else if (action == "Resize" || action == "parse")
            {
                DirParserByClass(directories, pathTextFile);
            }
            else
            {
                throw new ArgumentOutOfRangeException($"The action '{action}' does not exist.");
            }
        }

        public void DirParserByClass(string[] directories, string pathTextFile)
        {
            if (File.Exists(Path.Combine(pathTextFile, "dataset_base.txt")))
            {
                File.Delete(Path.Combine(pathTextFile, "dataset_base.txt"));
            }
            using (StreamWriter writer = new(Path.Combine(pathTextFile, "dataset_base.txt"), true))
            {
                foreach (string directory in directories)
                {
                    if (!Directory.Exists(directory))
                    {
                        throw new DirectoryNotFoundException($"The directory '{directory}' does not exist.");
                    }

                    foreach (string subdirectory in Directory.EnumerateDirectories(directory))
                    {
                        foreach (string filePath in Directory.EnumerateFiles(subdirectory))
                        {
                            string extension = Path.GetExtension(filePath);
                            if (extension == ".jpg" || extension == ".png")
                            {
                                writer.WriteLine(filePath);
                            }
                        }
                    }
                }
            }
        }

        public void DirParserByImgDim(string[] directories, string pathTextFile)
        {
            //using (StreamWriter writer = new(Path.Combine(pathTextFile, $"dataset_.{parentName}txt"), false))
            if (File.Exists(Path.Combine(pathTextFile, $"dataset_size224_224.txt")))
            {
                File.Delete(Path.Combine(pathTextFile, $"dataset_size224_224.txt"));
            }
            if (File.Exists(Path.Combine(pathTextFile, $"dataset_size299_299.txt")))
            {
                File.Delete(Path.Combine(pathTextFile, $"dataset_size299_299.txt"));
            }

            foreach (string directory in directories)
            {
                if (new DirectoryInfo(directory).Parent!.Name == "size224_224")
                {
                    if (!Directory.Exists(directory))
                    {
                        throw new DirectoryNotFoundException($"The directory '{directory}' does not exist.");
                    }
                    using (StreamWriter writer = new(Path.Combine(pathTextFile, $"dataset_size224_224.txt"), true))
                    {
                        foreach (string subdirectory in Directory.EnumerateDirectories(directory))
                        {
                            foreach (string filePath in Directory.EnumerateFiles(subdirectory))
                            {
                                string extension = Path.GetExtension(filePath);
                                if (extension == ".jpg" || extension == ".png")
                                {
                                    writer.WriteLine(filePath);
                                }
                            }
                        }
                    }
                }
                else if (new DirectoryInfo(directory).Parent!.Name == "size299_299")
                {
                    if (!Directory.Exists(directory))
                    {
                        throw new DirectoryNotFoundException($"The directory '{directory}' does not exist.");
                    }
                    using (StreamWriter writer = new(Path.Combine(pathTextFile, $"dataset_size299_299.txt"), true))
                    {
                        foreach (string subdirectory in Directory.EnumerateDirectories(directory))
                        {
                            foreach (string filePath in Directory.EnumerateFiles(subdirectory))
                            {
                                string extension = Path.GetExtension(filePath);
                                if (extension == ".jpg" || extension == ".png")
                                {
                                    writer.WriteLine(filePath);
                                }
                            }
                        }
                    }
                }
                else
                {
                    throw new DirectoryNotFoundException($"The directory does not exist.");
                }
            }
        }

        /// <summary>
        /// Constructs a list of directories based on the specified action.
        /// </summary>
        /// <param name="path">The base path to use when constructing the directories.</param>
        /// <param name="action">The action to base the directories on. Can be "resize", "parse", or "Augment".</param>
        /// <returns>A list of directories constructed based on the specified action.</returns>
        public List<string> pathMakerBasedOnAction(string path, string action)
        {
            List<string> directories = new List<string>();
            List<string> tempDir = new List<string>();

            if (action == "Resize" || action == "parse")
            {
                directories.Add(Path.Combine(path, "Medicinal_Leaf_dataset"));
                directories.Add(Path.Combine(path, "Medicinal_plant_dataset"));
            }
            else if (action == "Augment")
            {
                tempDir.Add(Path.Combine(path, "size224_224"));
                tempDir.Add(Path.Combine(path, "size299_299"));

                foreach (string dir in tempDir.ToList()) // Use ToList to create a copy for iteration
                {
                    directories.AddRange(pathMakerBasedOnAction(dir, "parse"));
                }
            }
            else if (action == "BckgrndRemove")
            {
                List<string> dirNames = new List<string> { "flipped", "noised", "resized", "rotated", "translated" };
                List<string> dimension = new List<string> { "size224_224", "size299_299" };
                foreach (string dirName in dirNames)
                {
                    foreach (string dim in dimension)
                    {
                        tempDir.Add(Path.Combine(path, dirName, dim));
                    }
                }

                foreach (string dir in tempDir.ToList()) // Use ToList to create a copy for iteration
                {
                    directories.AddRange(pathMakerBasedOnAction(dir, "parse"));
                }
            }
            else if (action == "Normalization")
            {
                List<string> dirNames = new List<string> { "flipped", "noised", "resized", "rotated", "translated" };
                List<string> dimension = new List<string> { "size224_224", "size299_299" };
                foreach (string dirName in dirNames)
                {
                    foreach (string dim in dimension)
                    {
                        tempDir.Add(Path.Combine(path, dirName, dim));
                    }
                }

                foreach (string dir in tempDir.ToList()) // Use ToList to create a copy for iteration
                {
                    directories.AddRange(pathMakerBasedOnAction(dir, "parse"));
                }
            }
            return directories;
        }
    }

    /// <summary>
    /// This class is responsible for writing images to a directory.
    /// </summary>
    internal class NewImageWrite
    {
        /// <summary>
        /// Creates a directory and writes an image to it.
        /// </summary>
        /// <param name="path">The path of the directory to create.</param>
        /// <param name="newImg">The image to write.</param>
        /// <param name="imgName">The name of the image file.</param>
        public static void DirrectoryCreate(string path, Mat newImg, string imgName)
        {
            if (!Directory.Exists(path))
            {
                try
                {
                    Directory.CreateDirectory(path);
                }
                catch (Exception e)
                {
                    Console.WriteLine($"Failed to create directory: {e}");
                }
            }

            WriteImage(path, newImg, imgName);
        }

        /// <summary>
        /// Writes an image to a file.
        /// </summary>
        /// <param name="path">The path of the file to write to.</param>
        /// <param name="newImg">The image to write.</param>
        /// <param name="imgName">The name of the image file.</param>
        private static void WriteImage(string path, Mat newImg, string imgName)
        {
            string newPath = Path.Combine(path, imgName);

            try
            {
                CvInvoke.Imwrite(newPath, newImg);
            }
            catch (IOException e)
            {
                Console.WriteLine("In NewImageWriter");
                Console.WriteLine($"Failed to write image: {e}");
            }
        }
    }

    /// <summary>
    /// This class is responsible for resizing images.
    /// </summary>
    internal class ImageResize
    {
        /// <summary>
        /// The directory to output the resized images to.
        /// </summary>
        public string OutputDirectory { get; } = "D:\\Project\\AI_ML_DS\\Minor_Project_Ai_Plant_Recognition\\Minor_Project_Ai_Plant_Recognition\\Data\\Dataset(resized)";

        private readonly NewImageWrite _newImageWrite = new NewImageWrite();

        /// <summary>
        /// Resizes the images specified in the text file at the given path.
        /// </summary>
        /// <param name="path">The path of the text file containing the image paths.</param>
        public void ResizeFactory(string path)
        {
            string textPath = Path.Combine(path, "dataset_base.txt");

            ResizeDirectory(textPath, 224, 224);
            ResizeDirectory(textPath, 299, 299);
        }

        public void ResizeDirectory(string path, int width, int height)
        {
            var lines = File.ReadLines(path);
            Parallel.ForEach(lines, (line) =>
            {
                Resizer(line, width, height);
            });
        }

        /// <summary>
        /// Resizes an image to the specified width and height.
        /// </summary>
        /// <param name="path">The path of the image to resize.</param>
        /// <param name="width">The width to resize to.</param>
        /// <param name="height">The height to resize to.</param>
        private void Resizer(string path, int width, int height)
        {
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);
            Mat resizedImage = new Mat();
            CvInvoke.Resize(image, resizedImage, new Size(width, height), 0, 0, Inter.Area);

            ImageWriterAssistance(path, resizedImage, width, height);
        }

        /// <summary>
        /// Assists in writing the resized image to the output directory.
        /// </summary>
        /// <param name="path">The path of the original image.</param>
        /// <param name="newImg">The resized image.</param>
        /// <param name="width">The width of the resized image.</param>
        /// <param name="height">The height of the resized image.</param>
        private void ImageWriterAssistance(string path, Mat newImg, int width, int height)
        {
            DirectoryInfo? dirParentInfo = new DirectoryInfo(path).Parent?.Parent;
            DirectoryInfo? dirInfo = new DirectoryInfo(path).Parent;
            string? dirName = dirInfo?.Name!;
            string? dirParentName = dirParentInfo?.Name!;
            string imgName = Path.GetFileName(path);
            string specificOutputDirectory = Path.Combine(OutputDirectory, $"size{width}_{height}", dirParentName, dirName);

            NewImageWrite.DirrectoryCreate(specificOutputDirectory, newImg, imgName);
        }
    }

    /// <summary>
    /// This class is responsible for Data Augmentation.
    /// </summary>
    internal class DataAugmentation
    {
        private readonly NewImageWrite _newImageWrite = new NewImageWrite();

        /// <summary>
        /// Augments the images specified in the text file at the given path.
        /// </summary>
        /// <param name="path">The path of the text file containing the image paths.</param>
        public void AugmentFactory(string path)
        {
            string path224 = Path.Combine(path, "dataset_size224_224.txt");
            string path299 = Path.Combine(path, "dataset_size299_299.txt");

            Task path224Task = Task.Run(() => AugmentDirectory(path224, "224Task"));
            Task path299Task = Task.Run(() => AugmentDirectory(path299, "299Task"));

            Task.WaitAll(path224Task, path299Task);
        }

        public void AugmentDirectory(string path, string taskName)
        {
            if (taskName == "224Task")
            {
                int totalLines = File.ReadLines(path).Count();
                {
                    using (StreamReader reader = new StreamReader(path))
                    {
                        string line;
                        while ((line = reader.ReadLine()!) != null)
                        {
                            FlipAugmenter(line);
                            RotateAugmenter(line);
                            NoiseAugmenter(line);
                            TranslateAugmenter(line);
                            CopyResizedImage(line);
                        }
                    }
                }
            }
            else if (taskName == "299Task")
            {
                int totalLines = File.ReadLines(path).Count();
                {
                    using (StreamReader reader = new StreamReader(path))
                    {
                        string line;
                        while ((line = reader.ReadLine()!) != null)
                        {
                            FlipAugmenter(line);
                            RotateAugmenter(line);
                            NoiseAugmenter(line);
                            TranslateAugmenter(line);
                            CopyResizedImage(line);
                        }
                    }
                }
            }
            else
            {
                throw new ArgumentOutOfRangeException($"The task '{taskName}' does not exist.");
            }
        }

        /// <summary>
        /// Augments an image by flipping it.
        /// </summary>
        /// <param name="path">The path of the image to augment.</param>
        private void FlipAugmenter(string path)
        {
            string action = "flipped";
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);
            Mat flippedImage = new Mat();
            CvInvoke.Flip(image, flippedImage, FlipType.Both);

            ImageWriterAssistance(path, flippedImage, action);
        }

        /// <summary>
        /// Augments an image by rotating it.
        /// </summary>
        /// <param name="path">The path of the image to augment.</param>
        private void RotateAugmenter(string path)
        {
            string action = "rotated";
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);
            Mat rotatedImage = new Mat();
            CvInvoke.Rotate(image, rotatedImage, RotateFlags.Rotate90Clockwise);

            ImageWriterAssistance(path, rotatedImage, action);
        }

        /// <summary>
        /// Augments an image by adding noise to it.
        /// </summary>
        /// <param name="path">The path of the image to augment.</param>
        private void NoiseAugmenter(string path)
        {
            string action = "noised";
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);
            Mat noisedImage = new Mat();
            CvInvoke.GaussianBlur(image, noisedImage, new Size(5, 5), 0);

            ImageWriterAssistance(path, noisedImage, action);
        }

        /// <summary>
        /// Augments an image by translating it.
        /// </summary>
        /// <param name="path">The path of the image to augment.</param>
        private void TranslateAugmenter(string path)
        {
            string action = "translated";
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);
            int imageWidth = image.Width;
            int imageHeight = image.Height;
            Mat translatedImage = new Mat();
            Matrix<float> shiftMatrix = new Matrix<float>(2, 3);
            Random rand = new Random();
            int shiftX = rand.Next(-50, 50);  // Random shift in x direction between -50 and 50
            int shiftY = rand.Next(-50, 50);  // Random shift in y direction between -50 and 50

            shiftMatrix[0, 0] = 1;  // Identity element
            shiftMatrix[1, 1] = 1;  // Identity element
            shiftMatrix[0, 2] = shiftX;  // Shift in x direction
            shiftMatrix[1, 2] = shiftY;  // Shift in y direction
            CvInvoke.WarpAffine(image, translatedImage, shiftMatrix, new Size(imageWidth, imageHeight), 0);

            ImageWriterAssistance(path, translatedImage, action);
        }

        /// <summary>
        /// Augments an image by copying it to the output directory.
        /// </summary>
        /// <param name="path"></param>
        private void CopyResizedImage(string path)
        {
            string action = "resized";
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);
            Mat copyResizedImage = image;

            ImageWriterAssistance(path, copyResizedImage, action);
        }

        /// <summary>
        /// The directory to output the augmented images to.
        /// </summary>
        public string OutputDirectory { get; } = "D:\\Project\\AI_ML_DS\\Minor_Project_Ai_Plant_Recognition\\Minor_Project_Ai_Plant_Recognition\\Data\\Dataset(augmented)";

        /// <summary>
        /// Assists in writing the augmented image to the output directory.
        /// </summary>
        /// <param name="path">The path of the original image.</param>
        /// <param name="newImg">The augmented image.</param>
        private void ImageWriterAssistance(string path, Mat newImg, string action)
        {
            DirectoryInfo? directoryParentParentInfo = new DirectoryInfo(path).Parent?.Parent?.Parent;
            DirectoryInfo? dirParentInfo = new DirectoryInfo(path).Parent?.Parent;
            DirectoryInfo? dirInfo = new DirectoryInfo(path).Parent;
            string? dirName = dirInfo?.Name!;
            string? dirParentName = dirParentInfo?.Name!;
            string? dirParentParentName = directoryParentParentInfo?.Name!;
            string imgName = Path.GetFileName(path);
            string specificOutputDirectory = Path.Combine(OutputDirectory, action, dirParentParentName, dirParentName, dirName);

            NewImageWrite.DirrectoryCreate(specificOutputDirectory, newImg, imgName);
        }
    }

    /// <summary>
    /// This class is responsible for removing the background from images.
    /// </summary>
    internal class BckgrndRemover
    {
        private readonly NewImageWrite _newImageWrite = new NewImageWrite();

        /// <summary>
        /// Removes the background from the images specified in the text file at the given path.
        /// </summary>
        /// <param name="path">The path of the text file containing the image paths.</param>
        public void RemoveBackgroundFactory(string path)
        {
            string path224 = Path.Combine(path, "dataset_size224_224.txt");
            string path299 = Path.Combine(path, "dataset_size299_299.txt");

            try
            {
                // Path to the Python DLL
                Runtime.PythonDLL = @"C:\Users\kumar\AppData\Local\Programs\Python\Python312\python312.dll";
                // Setting the PYTHONHOME environment variable
                Environment.SetEnvironmentVariable("PYTHONHOME", @"C:\Users\kumar\AppData\Local\Programs\Python\Python312", EnvironmentVariableTarget.Process);

                if (!PythonEngine.IsInitialized)
                {
                    PythonEngine.Initialize();
                }

                //var pyThreadState = PythonEngine.BeginAllowThreads();

                Task task224 = Task.Run(() => BackGrndRemoveDirectory(path224, "224Task"));
                Task task299 = Task.Run(() => BackGrndRemoveDirectory(path299, "299Task"));

                Task.WaitAll(task224, task299);

                //PythonEngine.EndAllowThreads(pyThreadState);
            }
            catch (Exception e)
            {
                WriteLine($"Failed to remove background: {e.Message}");
            }
            finally
            {
                PythonEngine.Shutdown();
            }

            //Task path224Task = Task.Run(() => BackGrndRemoveDirectory(path224, "224Task"));
            //Task path299Task = Task.Run(() => BackGrndRemoveDirectory(path299, "299Task"));

            //Task.WaitAll(path224Task, path299Task);
            //// Path to the Python DLL
            //Runtime.PythonDLL = @"C:\Users\kumar\AppData\Local\Programs\Python\Python312\python312.dll";
            //// Setting the PYTHONHOME environment variable
            //Environment.SetEnvironmentVariable("PYTHONHOME", @"C:\Users\kumar\AppData\Local\Programs\Python\Python312", EnvironmentVariableTarget.Process);

            //try
            //{
            //    // Initialize the Python Engine
            //    PythonEngine.Initialize();

            //    int totalLines = File.ReadLines(Path.Combine(path, "dataset.txt")).Count();
            //    using (var pbar = new ProgressBar(totalLines, "Removing Background", new ProgressBarOptions { ProgressCharacter = '#' }))
            //    {
            //        using (StreamReader reader = new StreamReader(Path.Combine(path, "dataset.txt")))
            //        {
            //            string line;
            //            while ((line = reader.ReadLine()!) != null)
            //            {
            //                PythonScriptRemoveBackground(line);
            //                pbar.Tick();
            //            }
            //        }
            //    }
            //}
            //catch (Exception e)
            //{
            //    Console.WriteLine($"Failed to remove background: {e.Message}");
            //}
            //finally
            //{
            //    // Shutdown the Python Engine
            //    PythonEngine.Shutdown();
            //}
        }

        private void BackGrndRemoveDirectory(string path, string taskName)
        {
            try
            {
                if (taskName == "224Task")
                {
                    int totalLines = File.ReadLines(path).Count();
 
                        using (StreamReader reader = new StreamReader(path))
                        {
                            string line;
                            while ((line = reader.ReadLine()!) != null)
                            {
                                PythonScriptRemoveBackground(line);
                            }
                        }
                }
                else if (taskName == "299Task")
                {
                    int totalLines = File.ReadLines(path).Count();
                    
                        using (StreamReader reader = new StreamReader(path))
                        {
                            string line;
                            while ((line = reader.ReadLine()!) != null)
                            {
                                PythonScriptRemoveBackground(line);
                            }
                        }
                    
                }
                else
                {
                    throw new ArgumentOutOfRangeException($"The task '{taskName}' does not exist.");
                }
            }
            catch (Exception e)
            {
                Console.WriteLine($"Failed to remove background: {e.Message}");
            }
        }

        /// <summary>
        /// Executes a Python script to remove the background from an image.
        /// </summary>
        /// <param name="path">The path of the image to process.</param>
        private void PythonScriptRemoveBackground(string path)
        {
            using (Py.GIL())
            {
                // Get the output path for the processed image
                string outputPath = ImageWriterAssistance(path);

                // Read the Python script
                string pythonScript = System.IO.File.ReadAllText(@"D:\Project\AI_ML_DS\Minor_Project_Ai_Plant_Recognition\Minor_Project_Ai_Plant_Recognition\SorceCode\remove_background.py");
                // Run the Python script
                PythonEngine.RunSimpleString(pythonScript);
                // Call the remove_backgrnd function from the Python script
                dynamic removeBackground = PythonEngine.RunSimpleString($"remove_backgrnd(r'{path}', r'{outputPath}')");
            }
        }

        /// <summary>
        /// The directory to output the images with the background removed to.
        /// </summary>
        public string OutputDirectory { get; } = "D:\\Project\\AI_ML_DS\\Minor_Project_Ai_Plant_Recognition\\Minor_Project_Ai_Plant_Recognition\\Data\\Dataset(background_removed)";

        /// <summary>
        /// Assists in writing the image with the background removed to the output directory.
        /// </summary>
        /// <param name="path">The path of the original image.</param>
        /// <param name="newImg">The image with the background removed.</param>
        private string ImageWriterAssistance(string path)
        {
            DirectoryInfo? dirParentParentParentInfo = new DirectoryInfo(path).Parent?.Parent?.Parent?.Parent;
            DirectoryInfo? dirParentParentInfo = new DirectoryInfo(path).Parent?.Parent?.Parent;
            DirectoryInfo? dirParentInfo = new DirectoryInfo(path).Parent?.Parent;
            DirectoryInfo? dirInfo = new DirectoryInfo(path).Parent;
            string? dirName = dirInfo?.Name!;
            string? dirParentName = dirParentInfo?.Name!;
            string? dirParentParentName = dirParentParentInfo?.Name!;
            string? dirParentParentParentName = dirParentParentParentInfo?.Name!;
            string imgName = Path.GetFileName(path);
            string specificOutputDirectory = Path.Combine(OutputDirectory, dirParentParentParentName, dirParentParentName, dirParentName, dirName);

            return Path.Combine(specificOutputDirectory, imgName);
            // Regular image write is not needed.
            //_newImageWrite.DirrectoryCreate(specificOutputDirectory, newImg, imgName);
        }
    }

    /// <summary>
    /// This class is responsble for normalization of images data.
    /// </summary>
    internal class Normalization
    {
        private readonly NewImageWrite _newImageWrite = new NewImageWrite();

        /// <summary>
        /// Normalizes the images specified in the text file at the given path.
        /// </summary>
        /// <param name="path">The path of the text file containing the image paths.</param>
        public void NormalizationFactor(string path)
        {
            string path224 = Path.Combine(path, "dataset_size224_224.txt");
            string path299 = Path.Combine(path, "dataset_size299_299.txt");

            Task path224Task = Task.Run(() => NormalizeDirectory(path224, "224Task"));
            Task path299Task = Task.Run(() => NormalizeDirectory(path299, "299Task"));

            Task.WaitAll(path224Task, path299Task);
            //int totalLines = File.ReadLines(Path.Combine(path, "dataset.txt")).Count();

            //using (var pbar = new ProgressBar(totalLines, "Resizing", new ProgressBarOptions { ProgressCharacter = '#' }))
            //{
            //    using (StreamReader reader = new StreamReader(Path.Combine(path, "dataset.txt")))
            //    {
            //        string line;
            //        while ((line = reader.ReadLine()!) != null)
            //        {
            //            NormalizeColorWise(line);
            //            pbar.Tick();
            //        }
            //    }
            //}
        }

        private void NormalizeDirectory(string path, string taskName)
        {
            if (taskName == "224Task")
            {
                int totalLines = File.ReadLines(path).Count();
                {
                    using (StreamReader reader = new StreamReader(path))
                    {
                        string line;
                        while ((line = reader.ReadLine()!) != null)
                        {
                            NormalizeColorWise(line);
                        }
                    }
                }
            }
            else if (taskName == "299Task")
            {
                int totalLines = File.ReadLines(path).Count();
                {
                    using (StreamReader reader = new StreamReader(path))
                    {
                        string line;
                        while ((line = reader.ReadLine()!) != null)
                        {
                            NormalizeColorWise(line);
                        }
                    }
                }
            }
            else
            {
                throw new ArgumentOutOfRangeException($"The task '{taskName}' does not exist.");
            }
        }

        /// <summary>
        /// Normalizes an image using min-max.
        /// </summary>
        /// <param name="path">The path of the image to process.</param>
        public void NormalizeColorWise(string path)
        {
            Mat image = CvInvoke.Imread(path, ImreadModes.Color);

            Mat normalizedImage = image.Clone();
            VectorOfMat vm = new VectorOfMat();
            CvInvoke.Split(image, vm);

            for (int i = 0; i < vm.Size; i++)
            {
                Mat channel = vm[i];
                CvInvoke.Normalize(channel, channel, 0, 255, NormType.MinMax);
            }
            CvInvoke.Merge(vm, normalizedImage);

            ImageWriterAssistance(path, normalizedImage);
        }

        /// <summary>
        /// The directory to output the normalized images to the directory.
        /// </summary>
        public string OutputDirectory { get; } = "D:\\Project\\AI_ML_DS\\Minor_Project_Ai_Plant_Recognition\\Minor_Project_Ai_Plant_Recognition\\Data\\Dataset(normalized)";

        /// <summary>
        /// Assists in writing the normalized image to the output directory.
        /// </summary>
        /// <param name="path">The path of the original image.</param>
        /// <param name="newImg">The image with the background removed.</param>

        private void ImageWriterAssistance(string path, Mat newImg)
        {
            DirectoryInfo? dirParentParentParentInfo = new DirectoryInfo(path).Parent?.Parent?.Parent?.Parent;
            DirectoryInfo? dirParentParentInfo = new DirectoryInfo(path).Parent?.Parent?.Parent;
            DirectoryInfo? dirParentInfo = new DirectoryInfo(path).Parent?.Parent;
            DirectoryInfo? dirInfo = new DirectoryInfo(path).Parent;
            string? dirName = dirInfo?.Name!;
            string? dirParentName = dirParentInfo?.Name!;
            string? dirParentParentName = dirParentParentInfo?.Name!;
            string? dirParentParentParentName = dirParentParentParentInfo?.Name!;
            string imgName = Path.GetFileName(path);
            string specificOutputDirectory = Path.Combine(OutputDirectory, dirParentParentParentName, dirParentParentName, dirParentName, dirName);

            NewImageWrite.DirrectoryCreate(specificOutputDirectory, newImg, imgName);
        }
    }
}ØOriginalContent¿™SelectionsëÉ•Caret¿•StartÕQ°£EndÕp*®FilePathŸxD:\Project\AI_ML_DS\Minor_Project_Ai_Plant_Recognition\Minor_Project_Ai_Plant_Recognition\SorceCode\DataPreprocessing.cs®Language¢C#ëíìÅ•Value Ÿgits noe runnung python script. i selected the code. commented code is my old code that was working fine¿®ResponseÖßContent⁄ÔThe issue might be related to how you're running the Python script. In your current code, you're using `PythonEngine.RunSimpleString` to run the Python script and call the function. This method runs the Python code in the current Python environment, but it doesn't return any results or errors. If there's an error in your Python script or function, you won't see it.

Instead, you should use `PythonEngine.Exec` to run the Python script, and then use `PythonEngine.GetBuiltins().InvokeMethod` to call the function. This will allow you to see any errors that occur. Here's how you can modify your code:

```csharp
private void PythonScriptRemoveBackground(string path)
{
    using (Py.GIL())
    {
        // Get the output path for the processed image
        string outputPath = ImageWriterAssistance(path);

        // Read the Python script
        string pythonScript = System.IO.File.ReadAllText(@"D:\Project\AI_ML_DS\Minor_Project_Ai_Plant_Recognition\Minor_Project_Ai_Plant_Recognition\SorceCode\remove_background.py");

        // Run the Python script
        PythonEngine.Exec(pythonScript);

        // Get the remove_backgrnd function from the Python script
        dynamic remove_backgrnd = PythonEngine.GetBuiltins().GetAttr("remove_backgrnd");

        // Call the remove_backgrnd function
        remove_backgrnd(path, outputPath);
    }
}
```

This code runs the Python script using `PythonEngine.Exec`, which executes the Python code in the current Python environment and raises an exception if there's an error. Then it gets the `remove_backgrnd` function from the Python script using `PythonEngine.GetBuiltins().GetAttr`, and calls the function with the image path and output path as arguments.

Please note that this code assumes that your Python script defines a function named `remove_backgrnd` that takes two arguments: the path of the image to process and the path to save the processed image. If your function has a different name or takes different arguments, you'll need to modify the code accordingly.§Type ¶StatusØFollowUpPromptsíŸ9How can I handle exceptions in the Python script from C#?Ÿ6Can I use other Python libraries in the Python script?≥CodeVulnerabilitiesê∂LoggedSkillInvocations¿